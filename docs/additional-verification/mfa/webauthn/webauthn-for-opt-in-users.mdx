---
id: webauthn-for-opt-in-users
title: WebAuthn for specific users
hide_title: true
sidebar_position: 2
description: >-
  Implement WebAuthn/Passkey multi-factor authentication for specific users based on custom criteria like admin roles or user preferences.
page_type: guide
recipe: mfa
category: multi-factor-authentication
---

import MFAPaidFeatureCallout from "/docs/additional-verification/mfa/_blocks/paid-feature-callout.mdx"

# WebAuthn for specific users

## Overview

This guide shows you how to implement a multi-factor authentication policy that requires WebAuthn/Passkey authentication only for specific users based on custom criteria such as admin roles, user preferences, or account types.

<MFAPaidFeatureCallout />

## Backend changes

You need to initialize the WebAuthn recipe and configure conditional MFA requirements based on your criteria.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import supertokens from "supertokens-node";
import { MultiFactorAuth } from "supertokens-node/recipe/multifactorauth";
import { WebAuthn } from "supertokens-node/recipe/webauthn";
import { AccountLinking } from "supertokens-node/recipe/accountlinking";
import { UserRoles } from "supertokens-node/recipe/userroles";
import Session from "supertokens-node/recipe/session";

supertokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init(),
        UserRoles.init(),
        // highlight-start
        WebAuthn.init({
            relyingParty: {
                name: "Your App Name",
                id: "yourdomain.com",
            },
        }),
        MultiFactorAuth.init({
            firstFactors: [
                MultiFactorAuth.FactorIds.EMAILPASSWORD,
                MultiFactorAuth.FactorIds.THIRDPARTY
            ],
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            // Check if user has admin role
                            const userRoles = await UserRoles.getRolesForUser(input.user.id);
                            if (userRoles.roles.includes("admin")) {
                                return [MultiFactorAuth.FactorIds.WEBAUTHN];
                            }

                            // Check if user has opted into WebAuthn MFA
                            const factors = await MultiFactorAuth.getRequiredSecondaryFactorsForUser(input.user.id);
                            if (factors.includes(MultiFactorAuth.FactorIds.WEBAUTHN)) {
                                return [MultiFactorAuth.FactorIds.WEBAUTHN];
                            }

                            // No MFA required for other users
                            return [];
                        }
                    }
                }
            }
        }),
        AccountLinking.init({
            shouldDoAutomaticAccountLinking: async (newAccountInfo, user, session, tenantId, userContext) => {
                return {
                    shouldAutomaticallyLink: true,
                    shouldRequireVerification: true
                }
            }
        })
        // highlight-end
    ]
});
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/multifactorauth"
	"github.com/supertokens/supertokens-golang/recipe/multifactorauth/mfatypes"
	"github.com/supertokens/supertokens-golang/recipe/webauthn"
	"github.com/supertokens/supertokens-golang/recipe/webauthn/webauthnmodels"
	"github.com/supertokens/supertokens-golang/recipe/accountlinking"
	"github.com/supertokens/supertokens-golang/recipe/accountlinking/accountlinkingtypes"
	"github.com/supertokens/supertokens-golang/recipe/userroles"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		Supertokens: &supertokens.ConnectionInfo{
			ConnectionURI: "...",
		},
		AppInfo: supertokens.AppInfo{
			AppName:       "...",
			APIDomain:     "...",
			WebsiteDomain: "...",
		},
		RecipeList: []supertokens.Recipe{
			session.Init(nil),
			userroles.Init(nil),
			// highlight-start
			webauthn.Init(webauthnmodels.TypeInput{
				RelyingParty: webauthnmodels.RelyingPartyConfig{
					Name: "Your App Name",
					ID:   "yourdomain.com",
				},
			}),
			multifactorauth.Init(mfatypes.TypeInput{
				FirstFactors: &[]string{
					multifactorauth.FactorIds.EMAILPASSWORD,
					multifactorauth.FactorIds.THIRDPARTY,
				},
				Override: &mfatypes.OverrideStruct{
					Functions: func(originalImplementation mfatypes.RecipeInterface) mfatypes.RecipeInterface {
						originalGetMFARequirementsForAuth := *originalImplementation.GetMFARequirementsForAuth
						(*originalImplementation.GetMFARequirementsForAuth) = func(input mfatypes.GetMFARequirementsForAuthInput, userContext supertokens.UserContext) (mfatypes.GetMFARequirementsForAuthResponse, error) {
							// Check if user has admin role
							userRoles, err := userroles.GetRolesForUser(input.User.ID, nil, userContext)
							if err != nil {
								return mfatypes.GetMFARequirementsForAuthResponse{}, err
							}
							
							for _, role := range userRoles.OK.Roles {
								if role == "admin" {
									return mfatypes.GetMFARequirementsForAuthResponse{
										RequiredSecondaryFactorsForUser: []string{multifactorauth.FactorIds.WEBAUTHN},
									}, nil
								}
							}

							// Check if user has opted into WebAuthn MFA
							factors, err := multifactorauth.GetRequiredSecondaryFactorsForUser(input.User.ID, userContext)
							if err != nil {
								return mfatypes.GetMFARequirementsForAuthResponse{}, err
							}
							
							for _, factor := range factors.OK.Factors {
								if factor == multifactorauth.FactorIds.WEBAUTHN {
									return mfatypes.GetMFARequirementsForAuthResponse{
										RequiredSecondaryFactorsForUser: []string{multifactorauth.FactorIds.WEBAUTHN},
									}, nil
								}
							}

							// No MFA required for other users
							return mfatypes.GetMFARequirementsForAuthResponse{
								RequiredSecondaryFactorsForUser: []string{},
							}, nil
						}
						return originalImplementation
					},
				},
			}),
			accountlinking.Init(accountlinkingtypes.TypeInput{
				ShouldDoAutomaticAccountLinking: func(newAccountInfo accountlinkingtypes.AccountInfoWithRecipeId, user *accountlinkingtypes.User, session *accountlinkingtypes.SessionContainer, tenantId string, userContext supertokens.UserContext) (accountlinkingtypes.ShouldDoAutomaticAccountLinkingResponse, error) {
					return accountlinkingtypes.ShouldDoAutomaticAccountLinkingResponse{
						ShouldAutomaticallyLink:   true,
						ShouldRequireVerification: true,
					}, nil
				},
			}),
			// highlight-end
		},
	})
}
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import multifactorauth, webauthn, accountlinking, userroles, session
from supertokens_python.recipe.multifactorauth.interfaces import RecipeInterface as MFARecipeInterface
from supertokens_python.recipe.multifactorauth.types import GetMFARequirementsForAuthInput
from supertokens_python.recipe.accountlinking.interfaces import RecipeInterface as AccountLinkingRecipeInterface
from supertokens_python.recipe.accountlinking.types import ShouldDoAutomaticAccountLinkingInput, ShouldDoAutomaticAccountLinkingResponse
from typing import List, Union, Dict, Any

def override_mfa_functions(original_implementation: MFARecipeInterface) -> MFARecipeInterface:
    original_get_mfa_requirements_for_auth = original_implementation.get_mfa_requirements_for_auth
    
    async def get_mfa_requirements_for_auth(input: GetMFARequirementsForAuthInput, user_context: Dict[str, Any]) -> List[Union[str, Dict[str, List[str]]]]:
        # Check if user has admin role
        user_roles_response = await userroles.get_roles_for_user(input.user.user_id)
        if "admin" in user_roles_response.roles:
            return [multifactorauth.FactorIds.WEBAUTHN]
        
        # Check if user has opted into WebAuthn MFA
        factors_response = await multifactorauth.get_required_secondary_factors_for_user(input.user.user_id)
        if multifactorauth.FactorIds.WEBAUTHN in factors_response.factors:
            return [multifactorauth.FactorIds.WEBAUTHN]
        
        # No MFA required for other users
        return []
    
    original_implementation.get_mfa_requirements_for_auth = get_mfa_requirements_for_auth
    return original_implementation

def override_account_linking_functions(original_implementation: AccountLinkingRecipeInterface) -> AccountLinkingRecipeInterface:
    original_should_do_automatic_account_linking = original_implementation.should_do_automatic_account_linking
    
    async def should_do_automatic_account_linking(input: ShouldDoAutomaticAccountLinkingInput, user_context: Dict[str, Any]) -> ShouldDoAutomaticAccountLinkingResponse:
        return ShouldDoAutomaticAccountLinkingResponse(
            should_automatically_link=True,
            should_require_verification=True
        )
    
    original_implementation.should_do_automatic_account_linking = should_do_automatic_account_linking
    return original_implementation

init(
    app_info=InputAppInfo(
        app_name="...",
        api_domain="...",
        website_domain="...",
    ),
    supertokens_config=SupertokensConfig(
        connection_uri="...",
    ),
    framework='fastapi',  # or 'flask' or 'django'
    recipe_list=[
        session.init(),
        userroles.init(),
        # highlight-start
        webauthn.init(
            relying_party=webauthn.RelyingPartyConfig(
                name="Your App Name",
                id="yourdomain.com",
            )
        ),
        multifactorauth.init(
            first_factors=[
                multifactorauth.FactorIds.EMAILPASSWORD,
                multifactorauth.FactorIds.THIRDPARTY
            ],
            override=multifactorauth.InputOverrideConfig(
                functions=override_mfa_functions
            )
        ),
        accountlinking.init(
            override=accountlinking.InputOverrideConfig(
                functions=override_account_linking_functions
            )
        )
        # highlight-end
    ]
)
```

</TabItem>
</BackendSDKTabs>

## Managing user MFA requirements

### Adding WebAuthn requirement for a user

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import { MultiFactorAuth } from "supertokens-node/recipe/multifactorauth";

// Add WebAuthn as a required factor for a specific user
await MultiFactorAuth.addToRequiredSecondaryFactorsForUser(
    "user-id", 
    MultiFactorAuth.FactorIds.WEBAUTHN
);
```

</TabItem>
<TabItem value="go">

```go
import "github.com/supertokens/supertokens-golang/recipe/multifactorauth"

// Add WebAuthn as a required factor for a specific user
_, err := multifactorauth.AddToRequiredSecondaryFactorsForUser(
    "user-id", 
    multifactorauth.FactorIds.WEBAUTHN, 
    userContext,
)
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe import multifactorauth

# Add WebAuthn as a required factor for a specific user
await multifactorauth.add_to_required_secondary_factors_for_user(
    "user-id", 
    multifactorauth.FactorIds.WEBAUTHN
)
```

</TabItem>
</BackendSDKTabs>

### Removing WebAuthn requirement for a user

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import { MultiFactorAuth } from "supertokens-node/recipe/multifactorauth";

// Remove WebAuthn requirement for a specific user
await MultiFactorAuth.removeFromRequiredSecondaryFactorsForUser(
    "user-id", 
    MultiFactorAuth.FactorIds.WEBAUTHN
);
```

</TabItem>
<TabItem value="go">

```go
import "github.com/supertokens/supertokens-golang/recipe/multifactorauth"

// Remove WebAuthn requirement for a specific user
_, err := multifactorauth.RemoveFromRequiredSecondaryFactorsForUser(
    "user-id", 
    multifactorauth.FactorIds.WEBAUTHN, 
    userContext,
)
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe import multifactorauth

# Remove WebAuthn requirement for a specific user
await multifactorauth.remove_from_required_secondary_factors_for_user(
    "user-id", 
    multifactorauth.FactorIds.WEBAUTHN
)
```

</TabItem>
</BackendSDKTabs>

## Frontend changes

The frontend setup is the same as the "WebAuthn for all users" guide:

<FrontendSDKTabs>
<TabItem value="reactjs">

```tsx
import React from 'react';
import SuperTokens, { SuperTokensWrapper } from "supertokens-auth-react";
import { MultiFactorAuthPreBuiltUI } from "supertokens-auth-react/recipe/multifactorauth/prebuiltui";
import { WebauthnPreBuiltUI } from "supertokens-auth-react/recipe/webauthn/prebuiltui";
import MultiFactorAuth from "supertokens-auth-react/recipe/multifactorauth";
import WebAuthn from "supertokens-auth-react/recipe/webauthn";
import EmailPassword from "supertokens-auth-react/recipe/emailpassword";
import ThirdParty from "supertokens-auth-react/recipe/thirdparty";
import Session from "supertokens-auth-react/recipe/session";

SuperTokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
        apiBasePath: "...",
        websiteBasePath: "..."
    },
    recipeList: [
        EmailPassword.init(),
        ThirdParty.init(),
        // highlight-start
        WebAuthn.init(),
        MultiFactorAuth.init(),
        // highlight-end
        Session.init()
    ]
});

function App() {
    return (
        <SuperTokensWrapper>
            {/* Your app content */}
        </SuperTokensWrapper>
    );
}

export default App;
```

</TabItem>
</FrontendSDKTabs>

## Multi-tenant setup

For multi-tenant applications, you can configure WebAuthn MFA requirements on a per-tenant basis:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import { Multitenancy } from "supertokens-node/recipe/multitenancy";

// Configure tenant with optional WebAuthn MFA
await Multitenancy.createOrUpdateTenant("customer1", {
    firstFactors: [
        MultiFactorAuth.FactorIds.EMAILPASSWORD,
        MultiFactorAuth.FactorIds.THIRDPARTY
    ],
    // Don't set requiredSecondaryFactors at tenant level
    // Let the getMFARequirementsForAuth function handle the logic
});

// For specific users in this tenant, you can still use:
await MultiFactorAuth.addToRequiredSecondaryFactorsForUser(
    "user-id", 
    MultiFactorAuth.FactorIds.WEBAUTHN
);
```

</TabItem>
<TabItem value="go">

```go
import "github.com/supertokens/supertokens-golang/recipe/multitenancy"

// Configure tenant with optional WebAuthn MFA
tenantResponse, err := multitenancy.CreateOrUpdateTenant("customer1", multitenancytypes.TenantConfig{
    FirstFactors: &[]string{
        multifactorauth.FactorIds.EMAILPASSWORD,
        multifactorauth.FactorIds.THIRDPARTY,
    },
    // Don't set RequiredSecondaryFactors at tenant level
    // Let the getMFARequirementsForAuth function handle the logic
})

// For specific users in this tenant, you can still use:
_, err = multifactorauth.AddToRequiredSecondaryFactorsForUser(
    "user-id", 
    multifactorauth.FactorIds.WEBAUTHN, 
    userContext,
)
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe import multitenancy, multifactorauth

# Configure tenant with optional WebAuthn MFA
await multitenancy.create_or_update_tenant(
    "customer1",
    first_factors=[
        multifactorauth.FactorIds.EMAILPASSWORD,
        multifactorauth.FactorIds.THIRDPARTY
    ],
    # Don't set required_secondary_factors at tenant level
    # Let the get_mfa_requirements_for_auth function handle the logic
)

# For specific users in this tenant, you can still use:
await multifactorauth.add_to_required_secondary_factors_for_user(
    "user-id", 
    multifactorauth.FactorIds.WEBAUTHN
)
```

</TabItem>
</BackendSDKTabs>

## Example: Admin-only WebAuthn MFA

Here's a complete example that requires WebAuthn MFA only for users with the "admin" role:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// First, assign admin role to a user
import { UserRoles } from "supertokens-node/recipe/userroles";

await UserRoles.createNewRoleOrAddPermissions("admin", []);
await UserRoles.addRoleToUser("user-id", "admin");

// The getMFARequirementsForAuth function will automatically require WebAuthn for admin users
```

</TabItem>
<TabItem value="go">

```go
import "github.com/supertokens/supertokens-golang/recipe/userroles"

// First, assign admin role to a user
_, err := userroles.CreateNewRoleOrAddPermissions("admin", []string{}, userContext)
_, err = userroles.AddRoleToUser("public", "user-id", "admin", userContext)

// The GetMFARequirementsForAuth function will automatically require WebAuthn for admin users
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe import userroles

# First, assign admin role to a user
await userroles.create_new_role_or_add_permissions("admin", [])
await userroles.add_role_to_user("public", "user-id", "admin")

# The get_mfa_requirements_for_auth function will automatically require WebAuthn for admin users
```

</TabItem>
</BackendSDKTabs>

## Testing the flow

1. **Regular users**: Sign up/in normally without MFA requirements
2. **Admin users**: After first factor authentication, they'll be prompted to set up and use WebAuthn
3. **Opt-in users**: Users who have been specifically configured for WebAuthn MFA will see the WebAuthn challenge

## Next steps

<ReferenceCard.Grid>
  <ReferenceCard href="/docs/additional-verification/mfa/webauthn/embed">
    <ReferenceCard.Title>
      Embed WebAuthn MFA UI
    </ReferenceCard.Title>
    <ReferenceCard.Description>
      Learn how to embed WebAuthn MFA components in custom pages or modals.
    </ReferenceCard.Description>
  </ReferenceCard>
  <ReferenceCard href="/docs/additional-verification/mfa/step-up-auth">
    <ReferenceCard.Title>
      Step-up authentication
    </ReferenceCard.Title>
    <ReferenceCard.Description>
      Require WebAuthn authentication for sensitive operations.
    </ReferenceCard.Description>
  </ReferenceCard>
  <ReferenceCard href="/docs/additional-verification/user-roles/introduction">
    <ReferenceCard.Title>
      User Roles
    </ReferenceCard.Title>
    <ReferenceCard.Description>
      Learn more about implementing role-based access control.
    </ReferenceCard.Description>
  </ReferenceCard>
</ReferenceCard.Grid>