---
id: webauthn-for-all-users
title: WebAuthn for all users
hide_title: true
sidebar_position: 1
description: >-
  Implement WebAuthn/Passkey multi-factor authentication that requires all users to complete passkey authentication before accessing the application.
page_type: guide
recipe: mfa
category: multi-factor-authentication
---

import MFAPaidFeatureCallout from "/docs/additional-verification/mfa/_blocks/paid-feature-callout.mdx"

# WebAuthn for all users

## Overview

This guide shows you how to implement a multi-factor authentication policy that requires all users to complete WebAuthn/Passkey authentication before they can access your application.

<MFAPaidFeatureCallout />

## Single tenant setup

### Backend changes

You need to initialize the WebAuthn recipe in your backend and configure the MFA requirements.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import supertokens from "supertokens-node";
import { MultiFactorAuth } from "supertokens-node/recipe/multifactorauth";
import { WebAuthn } from "supertokens-node/recipe/webauthn";
import { AccountLinking } from "supertokens-node/recipe/accountlinking";
import Session from "supertokens-node/recipe/session";

supertokens.init({
    supertokens: {
        connectionURI: "...",
    },
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init(),
        // highlight-start
        WebAuthn.init({
            // Configure WebAuthn settings
            relyingParty: {
                name: "Your App Name",
                id: "yourdomain.com", // Should match your domain
            },
        }),
        MultiFactorAuth.init({
            firstFactors: [
                MultiFactorAuth.FactorIds.EMAILPASSWORD,
                MultiFactorAuth.FactorIds.THIRDPARTY
            ],
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            return [MultiFactorAuth.FactorIds.WEBAUTHN]
                        }
                    }
                }
            }
        }),
        AccountLinking.init({
            shouldDoAutomaticAccountLinking: async (newAccountInfo, user, session, tenantId, userContext) => {
                return {
                    shouldAutomaticallyLink: true,
                    shouldRequireVerification: true
                }
            }
        })
        // highlight-end
    ]
});
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/multifactorauth"
	"github.com/supertokens/supertokens-golang/recipe/multifactorauth/mfatypes"
	"github.com/supertokens/supertokens-golang/recipe/webauthn"
	"github.com/supertokens/supertokens-golang/recipe/webauthn/webauthnmodels"
	"github.com/supertokens/supertokens-golang/recipe/accountlinking"
	"github.com/supertokens/supertokens-golang/recipe/accountlinking/accountlinkingtypes"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
	supertokens.Init(supertokens.TypeInput{
		Supertokens: &supertokens.ConnectionInfo{
			ConnectionURI: "...",
		},
		AppInfo: supertokens.AppInfo{
			AppName:       "...",
			APIDomain:     "...",
			WebsiteDomain: "...",
		},
		RecipeList: []supertokens.Recipe{
			session.Init(nil),
			// highlight-start
			webauthn.Init(webauthnmodels.TypeInput{
				RelyingParty: webauthnmodels.RelyingPartyConfig{
					Name: "Your App Name",
					ID:   "yourdomain.com", // Should match your domain
				},
			}),
			multifactorauth.Init(mfatypes.TypeInput{
				FirstFactors: &[]string{
					multifactorauth.FactorIds.EMAILPASSWORD,
					multifactorauth.FactorIds.THIRDPARTY,
				},
				Override: &mfatypes.OverrideStruct{
					Functions: func(originalImplementation mfatypes.RecipeInterface) mfatypes.RecipeInterface {
						originalGetMFARequirementsForAuth := *originalImplementation.GetMFARequirementsForAuth
						(*originalImplementation.GetMFARequirementsForAuth) = func(input mfatypes.GetMFARequirementsForAuthInput, userContext supertokens.UserContext) (mfatypes.GetMFARequirementsForAuthResponse, error) {
							return mfatypes.GetMFARequirementsForAuthResponse{
								RequiredSecondaryFactorsForUser: []string{multifactorauth.FactorIds.WEBAUTHN},
							}, nil
						}
						return originalImplementation
					},
				},
			}),
			accountlinking.Init(accountlinkingtypes.TypeInput{
				ShouldDoAutomaticAccountLinking: func(newAccountInfo accountlinkingtypes.AccountInfoWithRecipeId, user *accountlinkingtypes.User, session *accountlinkingtypes.SessionContainer, tenantId string, userContext supertokens.UserContext) (accountlinkingtypes.ShouldDoAutomaticAccountLinkingResponse, error) {
					return accountlinkingtypes.ShouldDoAutomaticAccountLinkingResponse{
						ShouldAutomaticallyLink:   true,
						ShouldRequireVerification: true,
					}, nil
				},
			}),
			// highlight-end
		},
	})
}
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import multifactorauth, webauthn, accountlinking, session
from supertokens_python.recipe.multifactorauth.interfaces import RecipeInterface as MFARecipeInterface
from supertokens_python.recipe.multifactorauth.types import GetMFARequirementsForAuthInput
from supertokens_python.recipe.accountlinking.interfaces import RecipeInterface as AccountLinkingRecipeInterface
from supertokens_python.recipe.accountlinking.types import ShouldDoAutomaticAccountLinkingInput, ShouldDoAutomaticAccountLinkingResponse
from typing import List, Union, Dict, Any

def override_mfa_functions(original_implementation: MFARecipeInterface) -> MFARecipeInterface:
    original_get_mfa_requirements_for_auth = original_implementation.get_mfa_requirements_for_auth
    
    async def get_mfa_requirements_for_auth(input: GetMFARequirementsForAuthInput, user_context: Dict[str, Any]) -> List[Union[str, Dict[str, List[str]]]]:
        return [multifactorauth.FactorIds.WEBAUTHN]
    
    original_implementation.get_mfa_requirements_for_auth = get_mfa_requirements_for_auth
    return original_implementation

def override_account_linking_functions(original_implementation: AccountLinkingRecipeInterface) -> AccountLinkingRecipeInterface:
    original_should_do_automatic_account_linking = original_implementation.should_do_automatic_account_linking
    
    async def should_do_automatic_account_linking(input: ShouldDoAutomaticAccountLinkingInput, user_context: Dict[str, Any]) -> ShouldDoAutomaticAccountLinkingResponse:
        return ShouldDoAutomaticAccountLinkingResponse(
            should_automatically_link=True,
            should_require_verification=True
        )
    
    original_implementation.should_do_automatic_account_linking = should_do_automatic_account_linking
    return original_implementation

init(
    app_info=InputAppInfo(
        app_name="...",
        api_domain="...",
        website_domain="...",
    ),
    supertokens_config=SupertokensConfig(
        connection_uri="...",
    ),
    framework='fastapi',  # or 'flask' or 'django'
    recipe_list=[
        session.init(),
        # highlight-start
        webauthn.init(
            relying_party=webauthn.RelyingPartyConfig(
                name="Your App Name",
                id="yourdomain.com",  # Should match your domain
            )
        ),
        multifactorauth.init(
            first_factors=[
                multifactorauth.FactorIds.EMAILPASSWORD,
                multifactorauth.FactorIds.THIRDPARTY
            ],
            override=multifactorauth.InputOverrideConfig(
                functions=override_mfa_functions
            )
        ),
        accountlinking.init(
            override=accountlinking.InputOverrideConfig(
                functions=override_account_linking_functions
            )
        )
        # highlight-end
    ]
)
```

</TabItem>
</BackendSDKTabs>

In the above code snippet, we:

1. **Initialize the WebAuthn recipe**: Configure the relying party information that identifies your application to the WebAuthn authenticators.

2. **Configure MFA requirements**: Override the `getMFARequirementsForAuth` function to always return `WEBAUTHN` as a required secondary factor.

3. **Enable account linking**: This is necessary because WebAuthn MFA creates a new recipe user that needs to be linked to the existing session user.

### Frontend changes

<FrontendSDKTabs>
<TabItem value="reactjs">

```tsx
import React from 'react';
import SuperTokens, { SuperTokensWrapper } from "supertokens-auth-react";
import { MultiFactorAuthPreBuiltUI } from "supertokens-auth-react/recipe/multifactorauth/prebuiltui";
import { WebauthnPreBuiltUI } from "supertokens-auth-react/recipe/webauthn/prebuiltui";
import MultiFactorAuth from "supertokens-auth-react/recipe/multifactorauth";
import WebAuthn from "supertokens-auth-react/recipe/webauthn";
import EmailPassword from "supertokens-auth-react/recipe/emailpassword";
import ThirdParty from "supertokens-auth-react/recipe/thirdparty";
import Session from "supertokens-auth-react/recipe/session";

SuperTokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
        apiBasePath: "...",
        websiteBasePath: "..."
    },
    recipeList: [
        EmailPassword.init(),
        ThirdParty.init(),
        // highlight-start
        WebAuthn.init(),
        MultiFactorAuth.init(),
        // highlight-end
        Session.init()
    ]
});

function App() {
    return (
        <SuperTokensWrapper>
            {/* Your app content */}
        </SuperTokensWrapper>
    );
}

export default App;
```

</TabItem>
</FrontendSDKTabs>

You also need to add the WebAuthn MFA route to your routing configuration:

<FrontendSDKTabs>
<TabItem value="reactjs">

```tsx
import { getSuperTokensRoutesForReactRouterDom } from "supertokens-auth-react/ui";
import { MultiFactorAuthPreBuiltUI } from "supertokens-auth-react/recipe/multifactorauth/prebuiltui";
import { WebauthnPreBuiltUI } from "supertokens-auth-react/recipe/webauthn/prebuiltui";
import { EmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/emailpassword/prebuiltui";
import { ThirdPartyPreBuiltUI } from "supertokens-auth-react/recipe/thirdparty/prebuiltui";

function AppWithRouting() {
    return (
        <BrowserRouter>
            <div className="App">
                <Routes>
                    {/* highlight-start */}
                    {getSuperTokensRoutesForReactRouterDom(require("react-router-dom"), [
                        EmailPasswordPreBuiltUI, 
                        ThirdPartyPreBuiltUI, 
                        MultiFactorAuthPreBuiltUI,
                        WebauthnPreBuiltUI
                    ])}
                    {/* highlight-end */}
                    <Route path="/" element={<Home />} />
                </Routes>
            </div>
        </BrowserRouter>
    );
}
```

</TabItem>
</FrontendSDKTabs>

## Multi-tenant setup

For multi-tenant applications, you can configure WebAuthn MFA requirements on a per-tenant basis:

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import { Multitenancy } from "supertokens-node/recipe/multitenancy";

// Create or update a tenant with WebAuthn MFA requirement
await Multitenancy.createOrUpdateTenant("customer1", {
    firstFactors: [
        MultiFactorAuth.FactorIds.EMAILPASSWORD,
        MultiFactorAuth.FactorIds.THIRDPARTY
    ],
    requiredSecondaryFactors: [MultiFactorAuth.FactorIds.WEBAUTHN]
});
```

</TabItem>
<TabItem value="go">

```go
import "github.com/supertokens/supertokens-golang/recipe/multitenancy"

// Create or update a tenant with WebAuthn MFA requirement
tenantResponse, err := multitenancy.CreateOrUpdateTenant("customer1", multitenancytypes.TenantConfig{
    FirstFactors: &[]string{
        multifactorauth.FactorIds.EMAILPASSWORD,
        multifactorauth.FactorIds.THIRDPARTY,
    },
    RequiredSecondaryFactors: &[]string{multifactorauth.FactorIds.WEBAUTHN},
})
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe import multitenancy

# Create or update a tenant with WebAuthn MFA requirement
await multitenancy.create_or_update_tenant(
    "customer1",
    first_factors=[
        multifactorauth.FactorIds.EMAILPASSWORD,
        multifactorauth.FactorIds.THIRDPARTY
    ],
    required_secondary_factors=[multifactorauth.FactorIds.WEBAUTHN]
)
```

</TabItem>
</BackendSDKTabs>

## Testing the flow

1. **Sign up or sign in** with your first factor (email/password or social login)
2. **Complete WebAuthn setup**: Users will be prompted to register a passkey if they haven't already
3. **WebAuthn challenge**: On subsequent logins, users will need to authenticate with their passkey as the second factor

The WebAuthn MFA flow includes these screens:
- **Factor selection**: Shows available second factors including WebAuthn/Passkeys
- **WebAuthn sign-in**: Prompts users to authenticate with their registered passkey
- **WebAuthn registration**: Allows users to register a new passkey if needed

## Important considerations

- **Device compatibility**: Ensure your users have devices that support WebAuthn (modern browsers with biometric sensors or external security keys)
- **Fallback options**: Consider implementing backup codes or alternative MFA methods for account recovery
- **User experience**: WebAuthn provides a seamless authentication experience but requires initial setup

## Next steps

<ReferenceCard.Grid>
  <ReferenceCard href="/docs/additional-verification/mfa/webauthn/webauthn-for-opt-in-users">
    <ReferenceCard.Title>
      WebAuthn for specific users
    </ReferenceCard.Title>
    <ReferenceCard.Description>
      Enable WebAuthn MFA only for certain users based on custom criteria.
    </ReferenceCard.Description>
  </ReferenceCard>
  <ReferenceCard href="/docs/additional-verification/mfa/step-up-auth">
    <ReferenceCard.Title>
      Step-up authentication
    </ReferenceCard.Title>
    <ReferenceCard.Description>
      Require additional WebAuthn authentication for sensitive operations.
    </ReferenceCard.Description>
  </ReferenceCard>
  <ReferenceCard href="/docs/additional-verification/mfa/backup-codes">
    <ReferenceCard.Title>
      Backup codes
    </ReferenceCard.Title>
    <ReferenceCard.Description>
      Implement recovery codes for users who lose access to their passkeys.
    </ReferenceCard.Description>
  </ReferenceCard>
</ReferenceCard.Grid>