---
title: Account Migration
hide_title: true
sidebar_position: 2
toc_max_heading_level: 4
description: Migrate your users from a legacy authentication provider to SuperTokens.
page_type: tutorial
category: migration
---


import BulkImportUserRequest from "./_blocks/bulk-import-user-request.mdx"
import BulkImportUsersCountRequest from "./_blocks/count-staged-users-request.mdx"
import BulkImportUsersGetRequest from "./_blocks/get-staged-users-request.mdx"
import BulkImportUsersAddRequest from "./_blocks/add-users-for-bulk-import-request.mdx"

# Account migration

<DescriptionText>
  The following guide will show you how to move your users from your current authentication solution to **SuperTokens**
</DescriptionText>

<Separator />

## Overview

The process of migrating your accounts breaks down into two parts:

### Creating new users on the fly

To ensure a smooth migration process, with no downtime, you need to be able to directly create new users from the legacy sign up flow.
This is necessary since there is a time gap between when you export all your data for bulk import and when you go live with **SuperTokens**. 

New users might get created in that interval through your legacy authentication provider. 
Hence, you also need to create them in **SuperTokens** to keep the data in sync.  

### Adding most of your users through a bulk import

After you have set in place the lazy migration process you can move on to adding most of your users.
This happens through the bulk import API.
The process is asynchronous and can work with large amounts of data.



## Before you start

This guide assumes that you have already integrated **SuperTokens** with your existing stack.
If you have not, please check the [Quickstart Guide](/docs/quickstart/introduction) and explore all the supported [authentication methods](/docs/authentication/overview).


## Steps

### 1. Update the legacy sign up flow 

Modify the legacy sign up flow logic to also create new users in **SuperTokens**.
You can do this through the `Import User` endpoint that allows you to directly create accounts.
Call the endpoint from the authentication flow used by your legacy provider.

<Accordion px="4">
## Auth0 Instructions


:::warning no-title
Auth0 does not expose password hashes or `TOTP` device information.
You will have to contact their support separately if you need this type of data.
:::

##### 1. Access the Auth0 Dashboard
##### 2. From the navigation menu go to *Actions* > *Library*
##### 3. Click *Create Action* > *Create custom action*
##### 4. Specify a custom name for your action and then select *Login/Post Login* as the trigger
##### 5. After the action has been created, click the *Add Secret* button and save your `SUPERTOKENS_CORE_API_KEY` as a secret
##### 5. Paste the following code in the editor

```typescript
exports.onExecutePostLogin = async (event, api) => {
  const SUPERTOKENS_CORE_URL = "<YOUR_SUPERTOKENS_CORE_URL>";
  const SUPERTOKENS_API_KEY = event.secrets.SUPERTOKENS_API_KEY;
  const auth0User = event.user;
  
  try {
    if (auth0User.app_metadata?.migrated_to_supertokens) {
      console.log(`User ${auth0User.user_id} already migrated`);
      return;
    }
    
    const userPayload = {
      externalUserId: auth0User.user_id,
      userMetadata: {
        auth0_user_id: auth0User.user_id,
        name: auth0User.name,
        nickname: auth0User.nickname,
        picture: auth0User.picture
	auth0_user_metadata: auth0User.user_metadata,
	auth0_app_metadata: auth0User.app_metadata
      },
      roles: auth0User.app_metadata?.roles || [],
      loginMethods: []
    };

    const ThirdPartyProviders = ['google-oauth2', 'facebook', 'github', 'apple'];
    
    auth0User.identities.forEach((identity, index) => {
      if(ThirdPartyProviders.includes(identity.provider)) {
	userPayload.loginMethods.push({
	    recipeId: "thirdparty",
	    thirdPartyId: mapProvider(identity.provider),
	    thirdPartyUserId: identity.user_id,
	    email: identity.profileData?.email ?? auth0User.email,
	    isVerified: identity.profileData?.email_verified ?? auth0User.email_verified ?? false,
	    isPrimary: index === 0,
	    timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
	  });
	}
      } else if (identity.provider === 'auth0' || identity.provider === 'Username-Password-Authentication') {
	// Auth0 does not export passworded hashes by default
	// You will have to contact their support and request them
	userPayload.loginMethods.push({
	  recipeId: "emailpassword",
	  email: identity.profileData?.email ?? auth0User.email,
	  // Request the password hash from Auth0 and then implement the function to retrieve the values 
	  passwordHash: getPasswordHash(identity.profileData?.email),
	  hashingAlgorithm: "bcrypt",
	  isVerified: identity.profileData?.email_verified ?? auth0User.email_verified ?? false,
	  isPrimary: index === 0,
	  timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
	});
      } else if (identity.provider === 'sms') {
	userPayload.loginMethods.push({
	  recipeId: "passwordless",
	  phoneNumber: identity.profileData?.phone_number ?? auth0User.phone_number,
	  isVerified: identity.profileData?.phone_verified ?? auth0User.phone_verified ?? false,
	  isPrimary: index === 0,
	  timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
	});
      } else if (identity.provider === 'email') {
	userPayload.loginMethods.push({
	  recipeId: "passwordless",
	  email: identity.profileData?.email || auth0User.email,
	  isVerified: identity.profileData?.email_verified ?? auth0User.email_verified ?? false,
	  isPrimary: index === 0,
	  timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
	});
      } else {
	throw new Error(`Uknown provider: ${identity.provider}`);
      }
    });
    
    const response = await fetch(`${SUPERTOKENS_CORE_URL}/bulk-import/import`, {
      method: 'POST',
      headers: {
        'api-key': SUPERTOKENS_API_KEY,
        'Content-Type': 'application/json; charset=utf-8'
      },
      body: JSON.stringify(userPayload)
    });
    
    const result = await response.json();
    
    if (response.ok && result.status === 'OK') {
      console.log(`User migrated: ${event.user.email || event.user.user_id}`);
      api.user.setAppMetadata('migrated_to_supertokens', true);
      api.user.setAppMetadata('supertokens_user_id', result.user?.id);
    } else {
      console.error(`Migration failed: ${JSON.stringify(result)}`);
    }
    
  } catch (error) {
    console.error('Migration error:', error.message);
  }
};

function mapProvider(strategy) {
  const mapping = {
    'google-oauth2': 'google',
    'facebook': 'facebook',
    'github': 'github',
    'apple': 'apple',
  };
  return mapping[strategy] || strategy;
}
```

</Accordion>

<br/>

:::info
If your application does not have a sign up process or if new users get created manually you can skip this step
:::


<HTTPRequestCard path="/bulk-import/import" method="post" title="Import User">
  <HTTPRequestCard.ShellExample>

```bash
curl --location --request POST '^{coreInfo.uri}/bulk-import/import' \
     --header 'api-key: ^{coreInfo.key}' \
     --header 'Content-Type: application/json; charset=utf-8' \
     --data '
    {
      "externalUserId": "user_12345",
      "userMetadata": {
        "firstName": "Jane",
        "lastName": "Doe",
        "department": "Engineering"
      },
      "userRoles": [{ "role": "admin", "tenantIds": [] }],
      "totpDevices": [
        {
          "secretKey": "JBSWY3DPEHPK3PXP",
          "period": 30,
          "skew": 1,
          "deviceName": "Main Device"
        }
      ],
      "loginMethods": [
        {
          "isVerified": true,
          "isPrimary": true,
          "timeJoinedInMSSinceEpoch": 1672531199000,
          "recipeId": "emailpassword",
          "email": "jane.doe@example.com",
          "passwordHash": "$2b$12$KIXQeFz...",
          "hashingAlgorithm": "bcrypt"
        }
      ]
    }
'
```

  </HTTPRequestCard.ShellExample>
  <HTTPRequestCard.NodeJSExample>

    ```tsx
    const BASE_URL = '^{coreInfo.uri}';
    const API_KEY = '^{coreInfo.key}';

    const url = `${BASE_URL}/bulk-import/import`;
    const options = {
      method: 'POST',
      headers: {
        'api-key': API_KEY,
        'Content-Type': 'application/json; charset=utf-8',
      },
      body: JSON.stringify({
          externalUserId: "user_12345",
          userRoles: [{ role: "admin", tenantIds: [] }],
          userMetadata: {
            firstName: "Jane",
            lastName: "Doe",
            department: "Engineering"
          },
          totpDevices: [
            {
              secretKey: "JBSWY3DPEHPK3PXP",
              period: 30,
              skew: 1,
              deviceName: "Main Device"
            }
          ],
          loginMethods: [
            {
              isVerified: true,
              isPrimary: true,
              timeJoinedInMSSinceEpoch: 1672531199000,
              recipeId: "emailpassword",
              email: "jane.doe@example.com",
              passwordHash: "$2b$12$KIXQeFz...",
              hashingAlgorithm: "bcrypt"
            }
          ]
      })
    }

    fetch(url, options)
      .then(response => response.json())
      .then(json => console.log(json))
      .catch(err => console.error(err));
    ```

  </HTTPRequestCard.NodeJSExample>
  <HTTPRequestCard.GoExample>

    ```go

    import (
      "fmt"
      "net/http"
      "strings"
      "io"
    )

    func main() {
      baseUrl := "^{coreInfo.uri}"
      apiKey := "^{coreInfo.key}"
      url := fmt.Sprintf("%s/bulk-import/import", baseUrl)
      payload := `{
          "externalUserId": "user_12345",
          "userMetadata": {
            "firstName": "Jane",
            "lastName": "Doe",
            "department": "Engineering"
          },
          "userRoles": [{ "role": "admin", "tenantIds": [] }],
          "totpDevices": [
            {
              "secretKey": "JBSWY3DPEHPK3PXP",
              "period": 30,
              "skew": 1,
              "deviceName": "Main Device"
            }
          ],
          "loginMethods": [
            {
              "isVerified": true,
              "isPrimary": true,
              "timeJoinedInMSSinceEpoch": 1672531199000,
              "recipeId": "emailpassword",
              "email": "jane.doe@example.com",
              "passwordHash": "$2b$12$KIXQeFz...",
              "hashingAlgorithm": "bcrypt"
            }
        ]
      }`

      req, _ := http.NewRequest("POST", url, strings.NewReader(payload))

      req.Header.Add("accept", "application/json")
      req.Header.Add("api-key", apiKey)
      req.Header.Add("content-type", "application/json")

      res, _ := http.DefaultClient.Do(req)

      defer res.Body.Close()
      body, _ := io.ReadAll(res.Body)

      fmt.Println(string(body))
    }
    ```

  </HTTPRequestCard.GoExample>
  <HTTPRequestCard.PythonExample>

    ```python
    import requests
    from typing import Dict, Any

    BASE_URL = "^{coreInfo.uri}"
    API_KEY = "^{coreInfo.key}"

    url = f"{BASE_URL}/bulk-import/import"

    payload: Dict[str, Any] = {
        "externalUserId": "user_12345",
        "userMetadata": {
            "firstName": "Jane",
            "lastName": "Doe",
            "department": "Engineering"
        },
        "userRoles": [{ "role": "admin", "tenantIds": [] }],
        "totpDevices": [
            {
                "secretKey": "JBSWY3DPEHPK3PXP",
                "period": 30,
                "skew": 1,
                "deviceName": "Main Device"
            }
        ],
        "loginMethods": [
            {
                "isVerified": True,
                "isPrimary": True,
                "timeJoinedInMSSinceEpoch": 1672531199000,
                "recipeId": "emailpassword",
                "email": "jane.doe@example.com",
                "passwordHash": "$2b$12$KIXQeFz...",
                "hashingAlgorithm": "bcrypt"
            }
        ]
    }

    headers = {
        "api-key": API_KEY,
        "Content-Type": "application/json",
    }

    response = requests.post(url, json=payload, headers=headers)

    print(response.json())
    ```

  </HTTPRequestCard.PythonExample>
  <HTTPRequestCard.DetailsModal>
<BulkImportUserRequest />
  </HTTPRequestCard.DetailsModal>
</HTTPRequestCard>



### 2. Export the accounts from your legacy provider

Export the users from your legacy authentication provider and adjust the data to match the request body schema used in the [**`Add Users for Bulk Import`**](#add-users-for-bulk-import-http-request) endpoint. 

<Accordion px="4">
## Auth0 Instructions
:::warning no-title
Auth0 does not export password hashes or `TOTP` device information.
You will have to contact their support and request them.
:::

#### 1. Create a management API application in Auth0
##### 1.1 Navigate to Auth0 Dashboard and the select `Applications` > `APIs`
##### 1.2 Select `Auth0 Management API`
##### 1.3 Go to `Machine to Machine Applications` tab
##### 1.4 Authorize your application or create a new one
##### 1.5 Grant the following permissions: `read:users`, `update:users`, `create:users`, `read:user_app_metadata`
##### 1.6 Save your `Domain`, `Client ID`, and `Client Secret`

#### 2. Get the management API access token
You need a valid Management API Access Token to export users.
Use the following `cURL` command to get the token:
```bash
curl --request POST \
  --url 'https://YOUR_DOMAIN.auth0.com/oauth/token' \
  --header 'content-type: application/json' \
  --data '{
    "client_id": "YOUR_CLIENT_ID",
    "client_secret": "YOUR_CLIENT_SECRET",
    "audience": "https://YOUR_DOMAIN.auth0.com/api/v2/",
    "grant_type": "client_credentials"
  }'
```

#### 3. Create the export job
Use the `POST /api/v2/jobs/users-exports` endpoint to create a job that exports all users. 

```bash
curl --request POST \
  --url 'https://YOUR_DOMAIN.auth0.com/api/v2/jobs/users-exports' \
  --header 'authorization: Bearer YOUR_MGMT_API_TOKEN' \
  --header 'content-type: application/json' \
  --data '{
    "format": "json",
    "fields": [
      {"name": "user_id"},
      {"name": "email"},
      {"name": "email_verified"},
      {"name": "name"},
      {"name": "nickname"},
      {"name": "picture"},
      {"name": "created_at"},
      {"name": "updated_at"},
      {"name": "identities"},
      {"name": "app_metadata"},
      {"name": "user_metadata"},
      {"name": "phone_number"},
      {"name": "phone_verified"}
    ]
  }'
```

#### 4. Check the export job status

Check if the export job has finalized with this request:

```bash
curl --request GET \
  --url 'https://YOUR_DOMAIN.auth0.com/api/v2/jobs/job_abc123xyz' \
  --header 'authorization: Bearer YOUR_MGMT_API_TOKEN'
```

#### 5. Download the export file

The previous request returns a `location` attribute in the response body if the export job has finalized.
Use it do access your data.

```bash
curl -o auth0_users.json.gz "LOCATION_URL_FROM_RESPONSE"
gunzip auth0_users.json.gz
```

Auth0 exports data in `NDJSON` format.
Convert it to JSON first:

```bash
cat auth0_users.json | jq -s '.' > auth0_users_array.json
```

#### 6. Transform the data to the SuperTokens format

:::warning no-title
Auth0 does not expose password hashes or `TOTP` device information.
You will have to contact their support separately if you need this type of data.
:::

```typescript
const fs = require('fs');

const auth0Users = JSON.parse(fs.readFileSync('auth0_users_array.json', 'utf8'));

const superTokensUsers = auth0Users.map(auth0User => {
  if(auth0User.user_metadata?.migrated_to_supertokens) {
    console.log(`User ${auth0User.user_id} already migrated`);
    return;
  }

  const userPayload = {
    externalUserId: event.user.user_id,
    userMetadata: {
      auth0_user_id: auth0User.user_id,
      name: auth0User.name,
      nickname: auth0User.nickname,
      picture: auth0User.picture,
      auth0_user_metadata: auth0User.user_metadata
      auth0_app_metadata: auth0User.app_metadata
    },
    roles: auth0User.app_metadata?.roles || [],
    loginMethods: [],
  };

  const ThirdPartyProviders = ['google-oauth2', 'facebook', 'github', 'apple'];
  
  auth0User.identities.forEach((identity, index) => {
    if(ThirdPartyProviders.includes(identity.provider)) {
      userPayload.loginMethods.push({
	  recipeId: "thirdparty",
	  thirdPartyId: mapProvider(identity.provider),
	  thirdPartyUserId: identity.user_id,
	  email: identity.profileData?.email ?? auth0User.email,
	  isVerified: identity.profileData?.email_verified ?? auth0User.email_verified ?? false,
	  isPrimary: index === 0,
	  timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
	});
      }
    } else if (identity.provider === 'auth0' || identity.provider === 'Username-Password-Authentication') {
      // Auth0 does not export passworded hashes by default
      // You will have to contact their support and request them
      userPayload.loginMethods.push({
        recipeId: "emailpassword",
        email: identity.profileData?.email ?? auth0User.email,
	// Request the password hash from Auth0 and then implement the function to retrieve the values 
        passwordHash: getPasswordHash(identity.profileData?.email),
        hashingAlgorithm: "bcrypt",
        isVerified: identity.profileData?.email_verified ?? auth0User.email_verified ?? false,
        isPrimary: index === 0,
        timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
      });
    } else if (identity.provider === 'sms') {
      userPayload.loginMethods.push({
	recipeId: "passwordless",
	phoneNumber: identity.profileData?.phone_number || auth0User.phone_number,
	isVerified: identity.profileData?.phone_verified ?? auth0User.phone_verified ?? false,
	isPrimary: index === 0,
	timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
      });
    } else if (identity.provider === 'email') {
      userPayload.loginMethods.push({
	recipeId: "passwordless",
	email: identity.profileData?.email || auth0User.email,
	isVerified: identity.profileData?.email_verified ?? auth0User.email_verified ?? false,
	isPrimary: index === 0,
	timeJoinedInMSSinceEpoch: new Date(auth0User.created_at).getTime()
      });
    } else {
      throw new Error(`Uknown provider: ${identity.provider}`);
    }
  });
  
  return userPayload;
});

fs.writeFileSync('supertokens_users.json', JSON.stringify({ users: superTokensUsers }, null, 2));

function mapProvider(auth0Provider) {
  const mapping = {
    'google-oauth2': 'google',
    'facebook': 'facebook',
    'github': 'github',
    'apple': 'apple'
  };
  return mapping[auth0Provider] || auth0Provider;
}

console.log(`Transformed ${superTokensUsers.length} users`);
```

</Accordion>

### 3. Perform the bulk migration process

:::warning

If your application has a sign up process please make sure that you have completed the [**first step**](#1-update-the-legacy-sign-up-flow).
Otherwise, new accounts that get created after you have exported your users are not available in **SuperTokens**. 

:::


#### 3.1 Add the accounts to import

Using the data that you have generated in the previous step, call the `Add Users for Bulk Import` endpoint.
This step stages the data that the background job imports later.

Keep in mind that the endpoint has a limit of **10000 users** per request.


<HTTPRequestCard path="/bulk-import/users" method="post" title="Add Users for Bulk Import">
  <HTTPRequestCard.ShellExample>

```bash
curl --location --request POST '^{coreInfo.uri}/bulk-import/users' \
     --header 'api-key: ^{coreInfo.key}' \
     --header 'Content-Type: application/json; charset=utf-8' \
     --data-raw '{
    users: [
    {
      "externalUserId": "user_2",
      "userMetadata": {
        "firstName": "John",
        "lastName": "Doe",
        "department": "Marketing"
      },
      "userRoles": [{ "role": "editor", "tenantIds": [] }],
      "loginMethods": [
        {
          "isVerified": true,
          "isPrimary": true,
          "timeJoinedInMSSinceEpoch": 1672617599000,
          "recipeId": "thirdparty",
          "email": "john.doe@gmail.com",
          "thirdPartyId": "google",
          "thirdPartyUserId": "google_987654321"
        }
      ]
  }
    ]
}
```

  </HTTPRequestCard.ShellExample>
  <HTTPRequestCard.NodeJSExample>

    ```tsx
    const BASE_URL = '^{coreInfo.uri}';
    const API_KEY = '^{coreInfo.key}';

    const url = `${BASE_URL}/bulk-import/users`;
    const options = {
      method: 'POST',
      headers: {
        'api-key': API_KEY,
        'Content-Type': 'application/json; charset=utf-8',
      },
      body: JSON.stringify({
        users: [
          {
            externalUserId: "user_2",
            userMetadata: {
              firstName: "John",
              lastName: "Doe",
              department: "Marketing"
            },
            userRoles: [{ role: "editor", tenantIds: [] }],
            loginMethods: [
              {
                isVerified: true,
                isPrimary: true,
                timeJoinedInMSSinceEpoch: 1672617599000,
                recipeId: "thirdparty",
                email: "john.doe@gmail.com",
                thirdPartyId: "google",
                thirdPartyUserId: "google_987654321"
              }
            ]
          }
        ]
      })
    }

    fetch(url, options)
      .then(response => response.json())
      .then(json => console.log(json))
      .catch(err => console.error(err));
    ```

  </HTTPRequestCard.NodeJSExample>
  <HTTPRequestCard.GoExample>

    ```go
    import (
      "fmt"
      "net/http"
      "strings"
      "io"
    )

    func main() {
      baseUrl := "^{coreInfo.uri}"
      apiKey := "^{coreInfo.key}"
      url := fmt.Sprintf("%s/bulk-import/users", baseUrl)
      payload := `{
          "users": [
            {
              "externalUserId": "user_2",
              "userMetadata": {
                "firstName": "John",
                "lastName": "Doe",
                "department": "Marketing"
              },
              "userRoles": [{ "role": "editor", "tenantIds": [] }],
              "loginMethods": [
                {
                  "isVerified": true,
                  "isPrimary": true,
                  "timeJoinedInMSSinceEpoch": 1672617599000,
                  "recipeId": "thirdparty",
                  "email": "john.doe@gmail.com",
                  "thirdPartyId": "google",
                  "thirdPartyUserId": "google_987654321"
                }
              ]
            }
          ]
        }`

      req, _ := http.NewRequest("POST", url, strings.NewReader(payload))
      req.Header.Add("accept", "application/json")
      req.Header.Add("api-key", apiKey)
      req.Header.Add("content-type", "application/json")

      res, _ := http.DefaultClient.Do(req)

      defer res.Body.Close()
      body, _ := io.ReadAll(res.Body)

      fmt.Println(string(body))
    }
    ```

  </HTTPRequestCard.GoExample>
  <HTTPRequestCard.PythonExample>

    ```python
    import requests
    from typing import Dict, Any

    BASE_URL = "^{coreInfo.uri}"
    API_KEY = "^{coreInfo.key}"

    url = f"{BASE_URL}/bulk-import/users"

    payload: Dict[str, Any] = {
        "users": [
            {
                "externalUserId": "user_2",
                "userMetadata": {
                    "firstName": "John",
                    "lastName": "Doe",
                    "department": "Marketing"
                },
                "userRoles": [{ "role": "editor", "tenantIds": [] }],
                "loginMethods": [
                    {
                        "isVerified": True,
                        "isPrimary": True,
                        "timeJoinedInMSSinceEpoch": 1672617599000,
                        "recipeId": "thirdparty",
                        "email": "john.doe@gmail.com",
                        "thirdPartyId": "google",
                        "thirdPartyUserId": "google_987654321"
                    }
                ]
            }
        ]
    }

    headers = {
        "api-key": API_KEY,
        "Content-Type": "application/json",
    }

    response = requests.post(url, json=payload, headers=headers)

    print(response.json())
    ```

  </HTTPRequestCard.PythonExample>
  <HTTPRequestCard.DetailsModal>
    <BulkImportUsersAddRequest />
  </HTTPRequestCard.DetailsModal>
</HTTPRequestCard>

:::info The Bulk Import Cron Job

Every 5 minutes the **SuperTokens** core service runs a cron job that goes through the staged users and tries to import them.
If a user gets imported successfully it gets removed from the staged list.

:::


#### 3.2 Monitor the progress of the job

To determine if the import flow has processed all the users call the [`Count Staged Users`](#count-staged-users-http-request) API.

Before doing that, first understand the different states in which a staged user can be.
During the import process, the user can have one of the following statuses:
- **NEW (not yet started)**: The import process has not yet picked up the user.
- **PROCESSING**: The import process has selected the user for import.
- **FAILED**: The import process has failed for that user.

If a user gets imported successfully it then gets removed from the staged list. Hence, no status exists for that state.

With this new information, get back to the `count users` endpoint.
The request counts the users that await import.
Pass a status filter as a query parameter (for example, `status=NEW`) to count only the users with that status.

Given that information, to check if your import is complete do the following:
1. Call the `count users` API once without any filters. If the count is 0, then the import process is complete.
2. If the count is not 0, then check if you still have rows that are getting processed (`status=PROCESSING`) or if there are rows that the import job has not yet picked up (`status=NEW`)
3. If the only rows that remain are the ones with the `FAILED` status, then proceed to step `3.3`. There you can see how to debug those issues.


<HTTPRequestCard path="/bulk-import/users/count" method="get" title="Count Staged Users">
  <HTTPRequestCard.ShellExample>

```bash
  curl --location --request GET '^{coreInfo.uri}/bulk-import/users/count?status=PROCESSING' \
     --header 'api-key: ^{coreInfo.key}' \
     --header 'Content-Type: application/json; charset=utf-8' \
```

  </HTTPRequestCard.ShellExample>
  <HTTPRequestCard.NodeJSExample>

  ```tsx
    const BASE_URL = '^{coreInfo.uri}';
    const API_KEY = '^{coreInfo.key}';

    const url = `${BASE_URL}/bulk-import/users/count?status=PROCESSING`;
    const options = {
      method: 'GET',
      headers: {
        'api-key': API_KEY,
        'Content-Type': 'application/json; charset=utf-8',
      },
    }

    fetch(url, options)
      .then(response => response.json())
      .then(json => console.log(json))
      .catch(err => console.error(err));
  ```

  </HTTPRequestCard.NodeJSExample>
  <HTTPRequestCard.GoExample>

    ```go
    import (
      "fmt"
      "net/http"
      "io"
    )

    func main() {
      baseUrl := "^{coreInfo.uri}"
      apiKey := "^{coreInfo.key}"
      url := fmt.Sprintf("%s/bulk-import/users/count?status=PROCESSING", baseUrl)

      req, _ := http.NewRequest("GET", url, nil)

      req.Header.Add("accept", "application/json")
      req.Header.Add("api-key", apiKey)
      req.Header.Add("content-type", "application/json")

      res, _ := http.DefaultClient.Do(req)

      defer res.Body.Close()
      body, _ := io.ReadAll(res.Body)

      fmt.Println(string(body))
    }
    ```

  </HTTPRequestCard.GoExample>
  <HTTPRequestCard.PythonExample>

    ```python
    import requests

    BASE_URL = "^{coreInfo.uri}"
    API_KEY = "^{coreInfo.key}"

    url = f"{BASE_URL}/bulk-import/users/count?status=PROCESSING"

    headers = {
        "api-key": API_KEY,
        "Content-Type": "application/json",
    }

    response = requests.post(url, headers=headers)

    print(response.json())
    ```

  </HTTPRequestCard.PythonExample>

  <HTTPRequestCard.DetailsModal>
    <BulkImportUsersCountRequest />
  </HTTPRequestCard.DetailsModal>
</HTTPRequestCard>


#### 3.3 Handle staged users that failed to import

Go through this step only if you have staged users that failed to import.
This can happen for a number of reasons. Some common ones:
- `Email` / `phoneNumber` already exists
- `externalUserId` is being already used by other user
- A primary user already exists for the email but with a different login method

If at the end of the previous step you have determined that you have staged users that failed to import debug the issues with the `get users` API.

<HTTPRequestCard path="/bulk-import/users" method="get" title="Get Staged Users">
  <HTTPRequestCard.ShellExample>

    ```bash
    curl --location --request GET '^{coreInfo.uri}/bulk-import/users?status=FAILED' \
        --header 'api-key: ^{coreInfo.key}' \
        --header 'Content-Type: application/json; charset=utf-8' \
    ```

  </HTTPRequestCard.ShellExample>
  <HTTPRequestCard.NodeJSExample>

    ```tsx
    const BASE_URL = '^{coreInfo.uri}';
    const API_KEY = '^{coreInfo.key}';

    const url = `${BASE_URL}/bulk-import/users?status=FAILED`;
    const options = {
      method: 'GET',
      headers: {
        'api-key': API_KEY,
        'Content-Type': 'application/json; charset=utf-8',
      },
    }

    fetch(url, options)
      .then(response => response.json())
      .then(json => console.log(json))
      .catch(err => console.error(err));
    ```

  </HTTPRequestCard.NodeJSExample>
  <HTTPRequestCard.GoExample>

    ```go
    import (
      "fmt"
      "net/http"
      "io"
    )

    func main() {
      baseUrl := "^{coreInfo.uri}"
      apiKey := "^{coreInfo.key}"
      url := fmt.Sprintf("%s/bulk-import/users?status=FAILED", baseUrl)

      req, _ := http.NewRequest("GET", url, nil)

      req.Header.Add("accept", "application/json")
      req.Header.Add("api-key", apiKey)
      req.Header.Add("content-type", "application/json")

      res, _ := http.DefaultClient.Do(req)

      defer res.Body.Close()
      body, _ := io.ReadAll(res.Body)

      fmt.Println(string(body))
    }
    ```

  </HTTPRequestCard.GoExample>
  <HTTPRequestCard.PythonExample>

    ```python
    import requests

    BASE_URL = "^{coreInfo.uri}"
    API_KEY = "^{coreInfo.key}"

    url = f"{BASE_URL}/bulk-import/users?status=FAILED"

    headers = {
        "api-key": API_KEY,
        "Content-Type": "application/json",
    }

    response = requests.post(url, headers=headers)

    print(response.json())
    ```

  </HTTPRequestCard.PythonExample>
  <HTTPRequestCard.DetailsModal>
    <BulkImportUsersGetRequest />
  </HTTPRequestCard.DetailsModal>
</HTTPRequestCard>



The response includes the import error messages for each specific user.
Use them to determine what you need to correct in your import data.
After you have fixed the issues, run the process again, from step `3.1`, only for the corrected data.



:::success You have successfully migrated your accounts


If all your data has imported then you can consider the account migration process complete.
Go on to the [session migration](/docs/migration/session-migration) step to complete the entire migration flow.

:::


## See also

<ReferenceCard.Grid>
  <ReferenceCard href="/docs/migration/session-migration" label="Session migration" />
  <ReferenceCard href="/docs/migration/legacy/about" label="Legacy migration" />
  <ReferenceCard href="/docs/post-authentication/user-management/introduction" label="User management" />
  <ReferenceCard href="/docs/post-authentication/account-linking/introduction" label="Account linking" />
</ReferenceCard.Grid>

