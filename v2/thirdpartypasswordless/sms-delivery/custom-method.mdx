---
id: custom-method
title: Method 4) Custom method
hide_title: true
---

<!-- COPY DOCS -->
<!-- ./passwordless/sms-delivery/custom-method.mdx -->

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs"
import TabItem from '@theme/TabItem';

# Method 4) Custom method

This method allows you provide a callback using which you can send SMSs however you like. The input to the callback will be SMS template variables, so you can freely create the content of the SMS as well. Use this method if you are:
- Using a third party SMS service that is **not** Twilio.
- You want to use another delivery methog like Whatsapp or FB Messenger.
- You want to do some custom spam protection before sending the SMS.
- You already have an SMS sending infrastructure and want to use that.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import supertokens from "supertokens-node";
import ^{recipeNameCapitalLetters} from "supertokens-node/recipe/^{codeImportRecipeName}";
import Session from "supertokens-node/recipe/session";

supertokens.init({
    appInfo: {
        apiDomain: "...",
        appName: "...",
        websiteDomain: "..."
    },
    recipeList: [
        ^{recipeNameCapitalLetters}.init({
            ^{nodeRecipeInitDefault}
            // highlight-start
            smsDelivery: {
                override: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        sendSms: async function ({
                            codeLifetime, // amount of time the code is alive for (in MS)
                            phoneNumber,
                            urlWithLinkCode, // magic link
                            userInputCode, // OTP
                        }) {
                            // TODO: create and send SMS
                        }
                    }
                }
            },
            // highlight-end
        }),
        Session.init()
    ]
});
```
</TabItem>
<TabItem value="go">

```go

import (
    "fmt"

    "github.com/supertokens/supertokens-golang/ingredients/smsdelivery"
    "github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}"
    "github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}/^{goModelName}"
    "github.com/supertokens/supertokens-golang/supertokens"
)

func main() {
    supertokens.Init(supertokens.TypeInput{
        RecipeList: []supertokens.Recipe{
            ^{codeImportRecipeName}.Init(^{goModelNameForInit}.TypeInput{
                ^{goRecipeInitDefault} // typecheck-only, removed from output
                // highlight-start
                SmsDelivery: &smsdelivery.TypeInput{
					Override: func(originalImplementation smsdelivery.SmsDeliveryInterface) smsdelivery.SmsDeliveryInterface {

						(*originalImplementation.SendSms) = func(input smsdelivery.SmsType, userContext supertokens.UserContext) error {
							// amount of time the code is alive for (in MS)
							codeLifetime := input.PasswordlessLogin.CodeLifetime
							phoneNumber := input.PasswordlessLogin.PhoneNumber

							// magic link
							urlWithLinkCode := input.PasswordlessLogin.UrlWithLinkCode

							// OTP
							userInputCode := input.PasswordlessLogin.UserInputCode
							fmt.Println(codeLifetime)
							fmt.Println(phoneNumber)
							fmt.Println(urlWithLinkCode)
							fmt.Println(userInputCode)
							// TODO: create and send SMS
							return nil
						}

						return originalImplementation
					},
				},
                // highlight-end
            }),
        },
    })
}
```
</TabItem>
<TabItem value="python">

```python
from supertokens_python import init, InputAppInfo
from supertokens_python.recipe.^{codeImportRecipeName}.types import Type^{recipeNameCapitalLetters}SmsDeliveryInput
from supertokens_python.recipe import ^{codeImportRecipeName}
from typing import Dict, Any
from supertokens_python.ingredients.smsdelivery.types import SMSDeliveryInterface
from supertokens_python.ingredients.smsdelivery.types import SMSDeliveryConfig


def custom_sms_deliver(original_implementation: SMSDeliveryInterface[Type^{recipeNameCapitalLetters}SmsDeliveryInput]) -> SMSDeliveryInterface[Type^{recipeNameCapitalLetters}SmsDeliveryInput]:
    # highlight-start
    async def send_sms(input_: Type^{recipeNameCapitalLetters}SmsDeliveryInput, user_context: Dict[str, Any]) -> None:
        # amount of time the code is alive for (in MS)
        _ = input_.code_life_time
        __ = input_.phone_number
        ___ = input_.url_with_link_code  # magic link
        ____ = input_.user_input_code  # OTP

        # TODO: create and send SMS...
    # highlight-end
    original_implementation.send_sms = send_sms
    return original_implementation


 # typecheck-only, removed from output
init(
    app_info=InputAppInfo(
        api_domain="...", app_name="...", website_domain="..."),
    framework='...',  # type: ignore
    recipe_list=[
        ^{codeImportRecipeName}.init(
            contact_config="",  # type: ignore # typecheck-only, removed from output
            flow_type="USER_INPUT_CODE",  # typecheck-only, removed from output
            sms_delivery=SMSDeliveryConfig(override=custom_sms_deliver)
        )
    ]
)
```

</TabItem>
</BackendSDKTabs>

If you call the original implementation function for `sendSms`, it will use the service that you have configured. If you have not configured any service, it will use the [default service](./default).

:::important
When using this callback, you must manage sending the SMS yourself.
:::
