---
id: react-nodejs-nestjs
title: Guided Tutorial
hide_title: true
hide_table_of_contents: true
---

import { Condition } from "/src/components/guides/Condition"
import { ToggleShowOnlySelected } from "/src/components/guides/GuidePageContext"

import ArchitectureWithSdk from '/guides/blocks/architecture-with-sdk.mdx'
import CustomUIHighlight from '/guides/blocks/highlight-custom-ui.mdx'
import BackendProjectStructure from '/guides/blocks/project-structure-nodejs-nestjs.mdx'
import FrontendProjectStructure from '/guides/blocks/project-structure-react.mdx'
import SuperTokensCoreSetup from '/guides/blocks/supertokens-core-setup.mdx'
import GuideNextSteps from '/guides/blocks/guide-next-steps.mdx'


# Guided Tutorial 
    
The following tutorial will guide you through the process of adding 
authentication features to a **React** applications that uses a **Node.js/Express** backend.

## Architecture Overview

First, let's get a high-level overview of how everything is supposed to work. 

<ArchitectureWithSdk />

## Project Structure

Use our starter project to get up and running quickly. It comes with full config examples 
based on your selection. Just run the following command to install everything:

```bash
npx create-supertokens-app@latest some-arguments 
```
The project that you just downloaded is split into two parts:

### `/backend`

<BackendProjectStructure />

### `/frontend`

<FrontendProjectStructure />

## Recipes

Recipes are the building blocks that you can use to enable different authentication functionalities. 
In this section we will talk about specific configuration options and guide you through how to manage
different login scenarios.

<Condition title="Multi-tenant Authentication" match={selection => selection.recipesVisiblity.mta}>

### Multi-tenant Authentication

:::caution
This is a paid feature. For self hosted users, [Sign up](/signup) to get a license key and follow the instructions sent to you by email.
Creation of tenants is free on the dev license key.

This feature is already enabled for managed service users. Creation of additional tenants is free on the provided development environment.
:::

Multi-tenancy allows you to have one user pool per tenant and different login methods for each tenant.
There are two levels of abstraction when talking about multi-tenancy in **SuperTokens**:

- `Tenant Level`: At this level you can have different user pools and/or databases per tenant. All of these tenants and their users are part of the same application. Users can also be shared across tenants.
- `App Level`: This is the top most level. Here you can define multiple apps that use the same **SuperTokens** core instance. Each app can have its own set of tenants and users.
This is useful when you want to run multiple apps within your organiazation or when you want to create different environments (`dev`, `staging`, `production`) for your apps.

For a more detailed presentation on multi-tenancy please check our separate [page](/page).

#### Creating a Tenant

If we look at our example app we can see that there are no custom configurations added to the backend server. 
That is because tenant configuration is done when we create or update a tenant.
You can do this by using the **Backend SDK** and calling the `createOrUpdateTenant` function.
Check the [create tenant guide](/guide) for more details.

:::info
You can also create and manage tenants using the **SuperTokens Dashboard**. 
Just go on the *Tenant Management* section and click the *Add Tenant* button.
:::


#### Frontent Configuration

On the frontend side there are two main aspects that need to be taken into account:

- Telling the `Multitenancy` recipe how to figure out which tenant is active. This can be done through the `getTenantId` function. 
In our example app we store the `tenantId` in `localStorage` and retrieve it each time the function gets called.
You can choose a different storage solution. As long as you return the correct `tenantId` everything will work properly. 
- Exposing the authentication routes based on the `tenantId`. 
The `Auth.tsx` page exports a component that renders an UI for selecting the tenant, if no `tenantId` has been set.
Or the actual login UI, after the user has selected their organization.

</Condition>

<Condition title="Multi-factor Authentication" match={selection => selection.recipesVisiblity.mfa}>

### Multi-factor Authentication

:::caution
This is a paid feature.

For self hosted users, Sign up to get a license key and follow the instructions sent to you by email. 
Using the dev license key is free. We only start charging you once you enable the feature in production using the provided production license key.

For managed service users, you can click on the "enable paid features" button on our dashboard, and follow the steps from there on. Once enabled, this feature is free on the provided development environment.
:::

Before going into the configuration details of this recipe let's first recap on some of the main concepts:
- **Factors** are the different ways in which a user can authenticate. 
- **Claims** are statements made by users about their identity. In the MFA context, we validate a user's `claim` by checking multiple authentication `factors`.
- **Account Linking** is the process of connecting multiple authentication methods to a single user account. 

<Condition title="Multi-factor Authentication" match={selection => selection.recipesVisiblity.mta}>

:::info
The `MFA` configuration in the context of multi-tenancy has to be setup when we actually create or update the tenant. 
You need to pass the same options for setting up **factors** but, in this case, as function arguments for the `createOrUpdateTenant` function.
:::

</Condition>


In our example app the **Account Linking** recipe is configured so that a user's account gets connected to an authentication method right after the first factor is completed, `shouldAutomaticallyLink: true`.
The second factor gets linked only if the first factor gets verified successfully, `shouldRequireVerification: true`.
For more details on how to customize the **Account Linking** behavior please check our [separate page](/page).

The `MultiFactorAuth` recipe is already configured to use `thirdparty` and `emailpassword` as the first authentication **factors**.
And `TOTP` (Time-based One-time Password) and Email and Phone `OTP` (One-time password) as the second factors.
On the `frontend` we only need to configure the first factors in the recipe initialization process.

Given this setup the authentication flow will work in the following way:
1. The user will see a form where they can either login using a social account or through email and password
2. If the attempt is successful, the user will be directed towards a factor choser screen. Here they can choose between `TOTP` and `OTP`.
3. Based on their selection, we will show the appropriate UI for the factor they chose.

Use the following [guide](/guide) to adjust the configuration based on your needs.

</Condition>

<Condition title="Email/Password Authentication" match={selection => selection.recipesVisiblity.emailPassword}>
  

### Email/Password Authentication

You do not have to configure anything in particular for this recipe.
The backend and the frontend code already includes the initialization steps in each config files. 

</Condition>

<Condition title="Social/Enterprise Login" match={selection => selection.recipesVisiblity.thirdparty}>

### Social/Enterprise Login 

The example app includes all the supported third party providers in the config files.
Just remove the ones that you do not want to use.

You will also have to update the credentials for each provider. For more details on how to do this check our [extensive instructions](/guide).

</Condition>

<Condition title="Passwordless Login" match={selection => selection.recipesVisiblity.passwordless}>

### Passwordless Login

For `passwordless` authentication you will first have to configure the way in which you want to identify your users.
You can choose between using `EMAIL`, `PHONE` or both, `EMAIL_OR_PHONE`, as the `contactMethod`.
Both the frontend and the backend config files will have to be updated with this.

Besides that, on the backend, you will have to set the authentication flow type.
**SuperTokens** exposes two different types of passwordless authentication: **one time password** and **magic link**.
You will have to set the `flowType` to `MAGIC_LINK`, `USER_INPUT_CODE` or `USER_INPUT_CODE_AND_MAGIC_LINK`, based on your use case.

</Condition>


## Session Management 

Besides all the authentication recipes that get initialized in the `recipeList` array, you might have noticed another call, `Session.init()`.
This enables the session management functionalities that **SuperTokens** provides for your application.

To protect your backend routes, you will have to use the `AuthGuard` over controller methods that need to be authenticated. 
You also have access to the `Session` decorator that can be used to access the `session` object inside your request handler.
Check the `app.controller.ts` file for a complete example.

On the frontend we export a `SessionAuth` component that you can use as a wrapper over routes that require authentication.

<Condition title="Multi-factor Authentication" match={selection => selection.recipesVisiblity.mfa}>

In the case of **multi-factor authentication** the MFA claim needs to also be verified.
SuperTokens will automatically add a session claim validator globally. Each time you use the `AuthGuard` the SDK will check if the claim is present and if it has the correct value.
In case you want to exlude certain routes from the claim check or you want to perform this step manually
check the [extensive docs](/docs) on how to do this.

</Condition>

<CustomUIHighlight />

## SuperTokens Core Setup

<SuperTokensCoreSetup />

## Next Steps

<GuideNextSteps />


