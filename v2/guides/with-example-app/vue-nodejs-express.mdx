---
id: react-nodejs-express 
title: Guided Tutorial
hide_title: true
---

import { Condition } from "/src/components/guides/Condition"
import { GuidePageContextProvider, ToggleShowOnlySelected } from "/src/components/guides/GuidePageContext"

import ExampleAppArchitecture from '/guides/blocks/example-app-architecture.mdx'

<GuidePageContextProvider>

# Guided Tutorial 
    
The following tutorial will guide you through the process of adding 
authentication features to a **React** applications that uses a **Node.js/Express** backend.

## Architecture Overview

First, let's get a high-level overview of how everything is supposed to work. 

<ExampleAppArchitecture />

## Project Structure

Use our starter project to get up and running quickly. It comes with full config examples 
based on your selection. Just run the following command to install everything:

```bash
npx create-supertokens-app@latest some-arguments 
```
The project that you just downloaded is split into two parts:

### `/backend`

This folder includes a sample server that exposes the authentication routes.


There are two files included in this project. 

##### `config.ts`

As the name suggests, this file configures the SuperTokens SDK and the features that your instance will use.
In it, you will find examples for the following setup steps:

1. Connecting to the **SuperTokens Core Service**. Replace the endpoint with the correct one based on your configuration and add your `apiKey`.
2. Specifying details about your application. Update the `appInfo` section with information specific to your application. 
3. Selecting and initialising the authentication **recipes** that you need. You will have to modify the parameters values with your own configuration values. We will go into detail about each recipe in the next sections. 
4. Configuring additional functionality like session or user management


##### `index.ts`

This file initializes a simple Express server that makes use of two functions to expose the auth functionalities:
- `middleware`: This adds the authentication routes to the Express App 
- `errorHandler`: This manages the errors that can be thrown in the authentication flows and includes standardized responses

There are also examples on how to configure CORS, and how to setup two additional endpoints. One for managing session data and one for working with tenants. 

:::important
The order in which each function is called matters. You need to add the CORS config first, then the **SuperTokens** middleware and after that the rest of the
routes that you have in your project.
:::


### `/frontend`

This folder includes a basic *SPA*, single page app, that uses the [SuperTokens Frontend SDK](/frontend-sdk) and a series of prebuilt components to provide an 
authentication UI for users.


##### `config.ts`

This file exports two main constants.
- The `SuperTokensConfig` object that describes the properties that should be used when we initialise the SDK.
- The `PreBuiltUIList`, which includes a series of prebuilt components that will be used in the authentication flows. 
In here you will have to adjust the `getApiDomain` and `getWebsiteDomain` functions based on your existing app setup.  
Besides that you will also have to change the configuration options for each specific authentication recipe. But we will get into more specific on this details in the next sections.

##### `App.tsx`

Here is where we make use of the previously defined config and we start everything off.
1. The SDK gets initialised based on the configuration that we have previously defined. 
2. The entire app tree is wrapped with the `SuperTokensWrapper` component. This will provide a state context that can be used in our next components.
2. The authentication routes get included by calling `getSuperTokensRoutesForReactRouterDom` with our previously defined UI list.
3. Routes that should be protected by the SDK are wrapped with the `SessionAuth` component

## Recipes

Recipes are the building blocks that you can use to enable different authentication functionalities. 
In this section we will talk about specific configuration options and guide you through how to manage
different login scenarios.

<Condition title="Multi-tenant Authentication" match={selection => selection.recipesVisiblity.mta}>

### Multi-tenant Authentication

Multi-tenancy allows you to have one user pool per tenant and different login methods for each tenant.

There are two levels of abstraction when talking about multi-tenancy in **SuperTokens**:

For a more detailed presentation on multi-tenancy please check our separate [page](/page).

#### Creating a tenant

If we look at our example app we can see that there are no custom configurations that added to the backend server. 
That is because tenant configuration is done when we create or update a tenant.
You can do this by using the **Backend SDK** and calling the `createOrUpdateTenant` function.
Check the [create tenant guide](/guide) for more all the details.

#### Frontent Configuration

On the frontend side there are two main aspects that need to be taken into account:

- Telling the `Multitenancy` recipe how to figure out which tenant is active. This can be done through the `getTenantId` function. 
In our example app we store the `tenantId` in the `localStorage` and retrieve it each time the function gets called.
You can choose a different storage solution. As long as you return the propert `tenantId` everything will work properly. 
- Exposing the authentication routes based on the `tenantId`. 
The `Auth.tsx` page exports a component that renders an UI for selecting the tenant, if no `tenantId` has been set.
Or the actual login UI, after the user has selected their organization.

#### Using the dashboard

You can also use the **SuperTokens Dashboard** in order to create and manage your tenants.

</Condition>

<Condition title="Multi-factor Authentication" match={selection => selection.recipesVisiblity.mfa}>

### Multi-factor Authentication

Before going into the configuration details of this recipe let's first recap on some of the main concepts:
- **Factors** are the different ways in which a user can authenticate. 
- **Claims** are statements made by users about their identity. In the MFA context, we validate a user's `claim` by checking multiple authentication `factors`.
- **Account Linking** is the process of connecting multiple authentication methods to a single user account. 

In our example app the **Account Linking** recipe is configured so that a user's account gets connected to an authentication method right after the first factor is completed, `shouldAutomaticallyLink: true`.
The second factor gets linked only if the first factor gets verified successfully, `shouldRequireVerification: true`.
For more details on how to customize the **Account Linking** behavior please check our [separate page](/page).

The `MultiFactorAuth` recipe is already configured to use `thirdparty` and `emailpassword` as the first authentication **factors**.
And TOTP (Time-based One-time Password) and Email and Phone OTP (One-time password) as the second factors.
On the `frontend` we only need to configure the first factors in the recipe initialization process.

Given this setup the authentication flow will work in the following way:
1. The user will see a form where they can either login using a social account or through email and password
2. If the attempt is successful, the user will be directed towards a factor choser screen. Here they can choose between `TOTP` and `OTP`.
3. Based on their selection, we will show the appropriate UI for the factor they chose.

Use the following [guide](/guide) to adjust the configuration based on your needs.

### Using the dashboard

You can also use the **SuperTokens Dashboard** in order to configure and mange the **Multi-Factor Authentication** feature.

</Condition>

<Condition title="Email/Password Authentication" match={selection => selection.recipesVisiblity.emailPassword}>
  

### Email/Password Authentication

You do not have to configure anything in particular for this recipe.
The backend and the frontend code already includes the initialization steps in each config files. 

</Condition>

<Condition title="Social/Enterprise Login" match={selection => selection.recipesVisiblity.thirdparty}>

### Social/Enterprise Login 

The example app includes all the supported third party providers in the config files.
Just remove the ones that you do not want to use.

You will also have to update the credentials for each provider. For more details on how to do this check our [extensive instructions](/guide).

</Condition>

<Condition title="Passwordless Login" match={selection => selection.recipesVisiblity.passwordless}>

### Passwordless Login

You will first have to configure the way in which you want to identify your users.
You can choose between using `EMAIL`, `PHONE` or both, `EMAIL_OR_PHONE`, as the `contactMethod`.
Both the frontend and the backend config files will have to be updated with this.

Besides that, on the backend, you will have to set the authentication flow type.
**SuperTokens** exposes two different types of passwordless authentication: **one time password** and **magic link**.
You will have to set the `flowType` to `MAGIC_LINK`, `USER_INPUT_CODE` or `USER_INPUT_CODE_AND_MAGIC_LINK`, based on your use case.

</Condition>

:::tip
If you plan on using your own **custom components** for the UI you will have to use the `supertokens-web-js` library and
manually call the authentication routes. 
Use the demo app for a guideline on how everything should work and check our [example components](/example/component) for more details on how to do this.
:::

## Session Management 

Besides all the authentication recipes that get initialized in the `recipeList` array, you might have noticed another call, `Session.init()`.
This enables the session management functionalities that **SuperTokens** provides for your application.

To protect your backend routes, you will have to include the `verifySession` middleware in the route definition code. 
The function limit access to the endpoint only to authenticated requests. It will also add the `session` object in `request` argument. We also expose a `SessionRequest` interface so that you can work with a proper types in your handler.

On the frontend we export a `SessionAuth` component that you can use as a wrapper over routes that require authentication.

<Condition title="Multi-factor Authentication" match={selection => selection.recipesVisiblity.mfa}>

In the case of **multi-factor authentication** the MFA claim needs to also be verified.
SuperTokens will automatically add a session claim validator globally. Each time you call `verifySession` the SDK will check if the claim is present and if it has the correct value.

In case you want to exlude certain routes from the claim check or you want to perform this step manually
check the [extensive docs](/docs) on how to do this.

</Condition>

## SuperTokens Core Setup

In our example app we used [try.supertokens.com](https://try.supertokens.com) to host the example app. You can replace the endpoint with your the correct one based on your configuration.

If you want to use our managed service, check this [guide](/guide) on how to sign up and create your environment. 
Otherwise, for self-hosted instances, you can follow either the [Docker](/core-service/docker) guide or the other [instructions](/docker), for non-docker scenarios.


## Next Steps

- [Learn how to protect your frontend routes](/docs/random)
- [Learn how to protect your backend routes](/docs/random)
- [Customize the look and feel of the pre-built UI](/docs/random)
- [See how you can manage your users and their metadata](/docs/random)

</GuidePageContextProvider>

