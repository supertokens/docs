---
id: react-java
title: Guided Tutorial
hide_title: true
---

import { Condition } from "/src/components/guides/Condition"
import { GuidePageContextProvider, ToggleShowOnlySelected } from "/src/components/guides/GuidePageContext"

import ArchitectureWithoutSdk from '/guides/blocks/architecture-without-sdk.mdx'
import CustomUIHighlight from '/guides/blocks/highlight-custom-ui.mdx'
import BackendProjectStructure from '/guides/blocks/project-structure-nodejs-express.mdx'
import FrontendProjectStructure from '/guides/blocks/project-structure-react.mdx'
import SuperTokensCoreSetup from '/guides/blocks/supertokens-core-setup.mdx'
import GuideNextSteps from '/guides/blocks/guide-next-steps.mdx'

<GuidePageContextProvider>

# Guided Tutorial 
    
## Architecture Overview

First, let's get a high-level overview of how everything is supposed to work. 

We do not have an SDK in the language that you have chosen. You will have to deploy
and expose a separate authentication server from your infrastructure. 

<ArchitectureWithoutSdk />

## Project Setup 

In this section we will guide you through how you should configure everything in order to kickstart **SuperTokens**.

As we mentioned in the previous setp, you will have to deploy a separate authentication server next to your existing backend.
We will use a **Node.js/Express** backend in this scenario and, in terms of the frontend app, we can make use of the our existing `React` library. 

Let's install the example app that we offer so that we have a reference point on how everything should be setup.   

```bash
npx create-supertokens-app@latest 
```

### Node.js Backed

<BackendProjectStructure />

:::note 
Session verification will be handled by your existing backend. We will show you how to do this in the specific section.
:::

### React Frontend 

<FrontendProjectStructure />

## Recipes

Recipes are the building blocks that you can use to enable different authentication functionalities. 
In this section we will talk about specific configuration options and guide you through how to manage
different login scenarios.

<Condition title="Multi-tenant Authentication" match={selection => selection.recipesVisiblity.mta}>

### Multi-tenant Authentication

:::caution
This is a paid feature. For self hosted users, [Sign up](/signup) to get a license key and follow the instructions sent to you by email.
Creation of tenants is free on the dev license key.

This feature is already enabled for managed service users. Creation of additional tenants is free on the provided development environment.
:::

Multi-tenancy allows you to have one user pool per tenant and different login methods for each tenant.
There are two levels of abstraction when talking about multi-tenancy in **SuperTokens**:

- `Tenant Level`: At this level you can have different user pools and/or databases per tenant. All of these tenants and their users are part of the same application. Users can also be shared across tenants.
- `App Level`: This is the top most level. Here you can define multiple apps that use the same **SuperTokens** core instance. Each app can have its own set of tenants and users.
This is useful when you want to run multiple apps within your organiazation or when you want to create different environments (`dev`, `staging`, `production`) for your apps.

For a more detailed presentation on multi-tenancy please check our separate [page](/page).

#### Creating a Tenant

In order to create new tenants and configure them you will have to call the **SuperTokens Core** API. 

#### Frontent Configuration

On the frontend side there are two main aspects that need to be taken into account:

- Telling the `Multitenancy` recipe how to figure out which tenant is active. This can be done through the `getTenantId` function. 
In our example app we store the `tenantId` in `localStorage` and retrieve it each time the function gets called.
You can choose a different storage solution. As long as you return the correct `tenantId` everything will work properly. 
- Exposing the authentication routes based on the `tenantId`. 
The `Auth.tsx` page exports a component that renders an UI for selecting the tenant, if no `tenantId` has been set.
Or the actual login UI, after the user has selected their organization.

</Condition>

<Condition title="Multi-factor Authentication" match={selection => selection.recipesVisiblity.mfa}>

### Multi-factor Authentication

:::caution
This is a paid feature.

For self hosted users, Sign up to get a license key and follow the instructions sent to you by email. 
Using the dev license key is free. We only start charging you once you enable the feature in production using the provided production license key.

For managed service users, you can click on the "enable paid features" button on our dashboard, and follow the steps from there on. Once enabled, this feature is free on the provided development environment.
:::

Before going into the configuration details of this recipe let's first recap on some of the main concepts:
- **Factors** are the different ways in which a user can authenticate. 
- **Claims** are statements made by users about their identity. In the MFA context, we validate a user's `claim` by checking multiple authentication `factors`.
- **Account Linking** is the process of connecting multiple authentication methods to a single user account. 

In our example app the **Account Linking** recipe is configured so that a user's account gets connected to an authentication method right after the first factor is completed, `shouldAutomaticallyLink: true`.
The second factor gets linked only if the first factor gets verified successfully, `shouldRequireVerification: true`.
For more details on how to customize the **Account Linking** behavior please check our [separate page](/page).

The `MultiFactorAuth` recipe is already configured to use `thirdparty` and `emailpassword` as the first authentication **factors**.
And `TOTP` (Time-based One-time Password) and Email and Phone `OTP` (One-time password) as the second factors.
On the `frontend` we only need to configure the first factors in the recipe initialization process.

Given this setup the authentication flow will work in the following way:
1. The user will see a form where they can either login using a social account or through email and password
2. If the attempt is successful, the user will be directed towards a factor choser screen. Here they can choose between `TOTP` and `OTP`.
3. Based on their selection, we will show the appropriate UI for the factor they chose.

Use the following [guide](/guide) to adjust the configuration based on your needs.

</Condition>

<Condition title="Email/Password Authentication" match={selection => selection.recipesVisiblity.emailPassword}>
  

### Email/Password Authentication

You do not have to configure anything in particular for this recipe.
The backend and the frontend code already includes the initialization steps in each config files. 

</Condition>

<Condition title="Social/Enterprise Login" match={selection => selection.recipesVisiblity.thirdparty}>

### Social/Enterprise Login 

The example app includes all the supported third party providers in the config files.
Just remove the ones that you do not want to use.

You will also have to update the credentials for each provider. For more details on how to do this check our [extensive instructions](/guide).

</Condition>

<Condition title="Passwordless Login" match={selection => selection.recipesVisiblity.passwordless}>

### Passwordless Login

For `passwordless` authentication you will first have to configure the way in which you want to identify your users.
You can choose between using `EMAIL`, `PHONE` or both, `EMAIL_OR_PHONE`, as the `contactMethod`.
Both the frontend and the backend config files will have to be updated with this.

Besides that, on the backend, you will have to set the authentication flow type.
**SuperTokens** exposes two different types of passwordless authentication: **one time password** and **magic link**.
You will have to set the `flowType` to `MAGIC_LINK`, `USER_INPUT_CODE` or `USER_INPUT_CODE_AND_MAGIC_LINK`, based on your use case.

</Condition>

<CustomUIHighlight />

## Session Management 

The frontend SDK will automatically add a `JWT`, JSON Web Token, that holds session information. 
You will have to process this token inside your existing API with a common library.
This way you can protect your routes by validating the session data. 

On the frontend we export a `SessionAuth` component that you can use as a wrapper over routes that require authentication.

## SuperTokens Core Setup

<SuperTokensCoreSetup />

## Next Steps

<GuideNextSteps />

</GuidePageContextProvider>

