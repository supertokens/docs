
import { GuideCondition } from "/src/components/guides/GuideCondition"
import { GuideRecipeLink } from "/src/components/guides/GuideRecipeLink"

<GuideCondition match={guide => guide.backend !== "nextjs"}>

Besides all the authentication recipes that get initialized in the `recipeList` array, you might have noticed another call, `Session.init()`.
This enables the session management functionalities that **SuperTokens** provides for your application.

To protect your backend routes, you will have to include the `verifySession` middleware in the route definition code. 
The function limits endpoint access only to authenticated requests. It will also add the `session` object in `request` argument. We expose a `SessionRequest` interface so that you can work with proper types in your handler.

On the frontend the `SessionAuth` component can be used as a wrapper over routes that require authentication. If a user has not logged in, they will automatically
get redirected to the public sign in page.

</GuideCondition>

<GuideCondition match={guide => guide.backend === "nextjs"}>

Besides all the authentication recipes that get initialized in th `recipeList` array, you might have noticed another call, `Session.init()`.
This enables the session management functionalities that **SuperTokens** provides for your application.

To protect your api functions, you will have to call the `withSession` wrapper function in order to verify the session data. Check the `user.ts` file for a full example. 

On the frontend the `SessionAuth` component can be used as a wrapper over routes that require authentication. If a user has not logged in, they will automatically
get redirected to the public sign in page.

</GuideCondition>
