---
id: change-email-post-login
title: Allow users to change their email
hide_title: true
---

import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import BackendSDKCasing from "/src/components/BackendSDKCasing"
import AppInfoForm from "/src/components/appInfoForm"
import TabItem from '@theme/TabItem';
import CustomAdmonition from "/src/components/customAdmonition"

# Allow users to change their email 

:::caution
SuperTokens does not provide the UI for users to update their email, you will need to create the UI and setup a route on your backend to have this functionality.
:::

In this section we will go over how you can create a route on your backend which can update a user's email. Calling this route will check if the new email is valid and not already in use and proceed to update the user's account with the new email. There are two types of flows here:

## Flow 1: Update email without verifying the new email.

In this flow a user is allowed to update their accounts email without verifying the new email id.

### Step 1: Creating the `/change-email` route
- You will need to create a route on your backend which is protected by the session verification middleware, this will ensure that only a authenticated user can access the protected route.
- To learn more about how to use the session verification middleware for other frameworks click [here](verify-session)

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

// highlight-start
app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {
    // TODO: see next steps
})

// highlight-end
```
</TabItem>

<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
)

// highlight-start
// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// TODO: see next steps
}

// highlight-end
```

</TabItem>


<TabItem value="python">

```python
# the following example uses flask
from supertokens_python.recipe.session.framework.flask import verify_session
from flask import Flask

app = Flask(__name__)

# highlight-start
@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_email():
    pass # TODO: see next steps
# highlight-end
```

</TabItem>

</BackendSDKTabs>

### Step 2: Validate the new email and update the account

- Validate the input email.
- Check that the account you are trying to update is not social account.
- Update the account with the input email.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// the following example uses express
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";
import supertokens from "supertokens-node";
import {isEmailChangeAllowed} from "supertokens-node/recipe/accountlinking"

let app = express();

app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {

    // highlight-start
    let session = req.session!;
    let email = req.body.email;

    // Validate the input email
    if (!isValidEmail(email)) {
        // TODO: handle invalid email error
        return
    }

    // Check that the account to be updated is not a social account
    {
        let userId = session!.getUserId();
        let userAccount = await supertokens.getUser(userId!);
        let loginMethod = userAccount?.loginMethods.find(lM => {
            return lM.recipeUserId.getAsString() === session.getRecipeUserId().getAsString()
        })!
        if (loginMethod.recipeId === "thirdparty") {
            // TODO: handle error, cannot update email for third party users.
            return
        }
    }

    if (!(await isEmailChangeAllowed(session.getRecipeUserId(), email, false))) {
        // this can come here if you have enabled the account linking feature, and 
        // if there is a security risk in changing this user's email.
    }

    // Update the email
    let resp = await ThirdPartyEmailPassword.updateEmailOrPassword({
        recipeUserId: session.getRecipeUserId(),
        email: email,
    });

    if (resp.status === "OK") {
        // TODO: send successfully updated email response
        return
    }
    if (resp.status === "EMAIL_ALREADY_EXISTS_ERROR") {
        // TODO: handle error that email exists with another account.
        return
    }
    if (resp.status === "EMAIL_CHANGE_NOT_ALLOWED_ERROR") {
        // This is possible if you have enabled account linking.
        // See our docs for account linking to know more about this. 
        // TODO: tell the user to contact support.
    }
    throw new Error("Should never come here");
    // highlight-end

})

function isValidEmail(email: string) {
    let regexp = new RegExp(
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    );
    return regexp.test(email);
}
```


</TabItem>

<TabItem value="go">

```go

import (
	"encoding/json"
	"log"
	"net/http"
	"regexp"

	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
)

type RequestBody struct {
	Email string
}

// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// highlight-start
	sessionContainer := session.GetSessionFromRequestContext(r.Context())

	var requestBody RequestBody
	err := json.NewDecoder(r.Body).Decode(&requestBody)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}

	// validate the input email
	if !isValidEmail(requestBody.Email) {
		// TODO: handle invalid email error
		return
	}

	// check that the account is not a social account
	userId := sessionContainer.GetUserID()
	userAccount, err := thirdpartyemailpassword.GetUserById(userId)
	if err != nil {
		// TODO: handle error
		return
	}

	if userAccount.ThirdParty != nil {
		// TODO: handle error, cannot update email for third party accounts
		return
	}

	// update the email
    tenantId := "public"
	updateResponse, err := thirdpartyemailpassword.UpdateEmailOrPassword(userId, &requestBody.Email, nil, nil, &tenantId)

	if err != nil {
		// TODO: handle error
	}

	if updateResponse.OK != nil {
		// TODO: send successfully updated email response
		return
	}

	if updateResponse.EmailAlreadyExistsError != nil {
		// TODO: handle error that email exists with another account
		return
	}

	log.Fatal("should not reach here")
	// highlight-end

}

func isValidEmail(email string) bool {
	emailCheck, err := regexp.Match(`^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$`, []byte(email))
	if err != nil {
		return false
	}
	return emailCheck
}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.thirdpartyemailpassword.syncio import get_user_by_id, update_email_or_password
from supertokens_python.recipe.thirdpartyemailpassword.interfaces import UpdateEmailOrPasswordOkResult, UpdateEmailOrPasswordEmailAlreadyExistsError
from flask import g, request, Flask
from re import fullmatch

app = Flask(__name__)

@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_email():
    # highlight-start
    session: SessionContainer = g.supertokens

    request_body = request.get_json()

    email: str = str(request_body["email"])  # type: ignore
    if request_body is None:
        # TODO: handle invalid body error
        return

    # validate the input email
    if not is_valid_email(email):
        # TODO: handle invalid email error
        return

    # check that the account is not a social account
    user_id = session.get_user_id()
    user_info = get_user_by_id(user_id)

    if user_info is None:
        # TODO handle error, user does not exist
        return

    if user_info.third_party_info is not None:
        # TODO handle error, cannot update email for social account
        return

    # update the users email
    update_response = update_email_or_password(user_id, email=email)

    if isinstance(update_response, UpdateEmailOrPasswordOkResult):
        # TODO send successful email update response
        return

    if isinstance(update_response, UpdateEmailOrPasswordEmailAlreadyExistsError):
        # TODO handle error, email already exists
        return

    raise Exception("Should never reach here")

    # highlight-end

async def is_valid_email(value: str) -> bool:
    return (
        fullmatch(
            r'^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,'
            r"3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$",
            value,
        )
        is not None
    )
```

</TabItem>
</BackendSDKTabs>

## Flow 2: Updating email after verifying the new email. 

In this flow the user's account is updated once they have verified the new email.

### Step 1: Creating the `/change-email` route
- You will need to create a route on your backend which is protected by the session verification middleware, this will ensure that only a authenticated user can access the protected route.
- To learn more about how to use the session verification middleware for other frameworks click [here](verify-session)

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";

let app = express();

// highlight-start
app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {
    // TODO: see next steps
})

// highlight-end
```
</TabItem>

<TabItem value="go">

```go
import (
	"net/http"

	"github.com/supertokens/supertokens-golang/recipe/session"
)

// highlight-start
// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// TODO: see next steps
}

// highlight-end
```

</TabItem>


<TabItem value="python">

```python
# the following example uses flask
from supertokens_python.recipe.session.framework.flask import verify_session
from flask import Flask

app = Flask(__name__)

# highlight-start
@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_email():
    pass # TODO: see next steps
# highlight-end
```

</TabItem>

</BackendSDKTabs>

### Step 2: Validate the email and initiate the email verification flow

- Validate the input email
- Check that the user's account is not a social account.
- Check if the input email is associated with an account.
- Check if the input email is already verified.
- If the email is **NOT** verified, create and send the verification email.
- If the email is verified, update the account with the new email.

<AppInfoForm
    askForWebsiteDomain
>

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
// the following example uses express
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification";
import { verifySession } from "supertokens-node/recipe/session/framework/express";
import { SessionRequest } from "supertokens-node/framework/express"
import express from "express";
import supertokens from "supertokens-node";
import {isEmailChangeAllowed} from "supertokens-node/recipe/accountlinking"

let app = express();

app.post("/change-email", verifySession(), async (req: SessionRequest, res: express.Response) => {

    // highlight-start
    let session = req.session!;
    let email = req.body.email;

    // validate the input email
    if (!isValidEmail(email)) {
        // TODO: handle error, email is invalid
        return
    }

    // Check if the user's account is not a third party account
    {
        let userId = session!.getUserId();
        let userAccount = await supertokens.getUser(userId!);
        let loginMethod = userAccount?.loginMethods.find(lM => {
            return lM.recipeUserId.getAsString() === session.getRecipeUserId().getAsString()
        })!
        if (loginMethod.recipeId === "thirdparty") {
            // TODO: handle error, cannot update email for third party users.
            return
        }
    }

    // Then, we check if the email is verified for this user ID or not.
    // It is important to understand that SuperTokens stores email verification
    // status based on the user ID AND the email, and not just the email.
    let isVerified = await EmailVerification.isEmailVerified(session.getRecipeUserId(), email);

    if (!isVerified) {
        if (!(await isEmailChangeAllowed(session.getRecipeUserId(), email, false))) {
            // this can come here if you have enabled the account linking feature, and 
            // if there is a security risk in changing this user's email.
            return res.status(400).send("Email change not allowed. Please contact support");
        }
        // Before sending a verification email, we check if the email is already
        // being used by another user. If it is, we throw an error.
        let user = (await supertokens.getUser(session.getUserId()))!;
        for (let i = 0; i < user?.tenantIds.length; i++) {
            // Since once user can be shared across many tenants, we need to check if
            // the email already exists in any of the tenants.
            let usersWithEmail = await supertokens.listUsersByAccountInfo(user.tenantIds[i], {
                email
            });
            for (let y = 0; y < usersWithEmail.length; y++) {
                if (usersWithEmail[y].id !== session.getUserId()) {
                    // TODO handle error, email already exists with another user.
                    return
                }
            }
        }

        // Now we create and send the email verification link to the user for the new email.
        await EmailVerification.sendEmailVerificationEmail(session.getTenantId(), session.getUserId(), session.getRecipeUserId(), email);

        // TODO send successful response that email verification email sent.
        return
    }

    if (!(await isEmailChangeAllowed(session.getRecipeUserId(), email, true))) {
        // this can come here if you have enabled the account linking feature, and 
        // if there is a security risk in changing this user's email.
        return res.status(400).send("Email change not allowed. Please contact support");
    } 

    // Since the email is verified, we try and do an update
    let resp = await ThirdPartyEmailPassword.updateEmailOrPassword({
        recipeUserId: session.getRecipeUserId(),
        email: email,
    });

    if (resp.status === "OK") {
        // TODO: send successful response that email has been updated
        return
    }
    if (resp.status === "EMAIL_ALREADY_EXISTS_ERROR") {
        // TODO: handle error, email already exists for another account
        return
    }
    throw new Error("Should never come here");
    // highlight-end

})

function isValidEmail(email: string) {
    let regexp = new RegExp(
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    );
    return regexp.test(email);
}
```


</TabItem>

<TabItem value="go">

```go
import (
	"encoding/json"
	"log"
	"net/http"
	"regexp"

	"github.com/supertokens/supertokens-golang/recipe/emailverification"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
)

type RequestBody struct {
	Email string
}

// the following example uses net/http
func main() {
	_ = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		// Wrap the API handler in session.VerifySession
		session.VerifySession(nil, changeEmailAPI).ServeHTTP(rw, r)
	})
}

func changeEmailAPI(w http.ResponseWriter, r *http.Request) {
	// highlight-start
	sessionContainer := session.GetSessionFromRequestContext(r.Context())

	var requestBody RequestBody
	err := json.NewDecoder(r.Body).Decode(&requestBody)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}

	// validate the input email
	if !isValidEmail(requestBody.Email) {
		// TODO: handle invalid email error
		return
	}

	// check that the account is not a social account
	userId := sessionContainer.GetUserID()
	userAccount, err := thirdpartyemailpassword.GetUserById(userId)
	if err != nil {
		// TODO: handle error
		return
	}

	if userAccount.ThirdParty != nil {
		// TODO: handle error, cannot update email for third party accounts
		return
	}

	// Then, we check if the email is verified for this user ID or not.
	// It is important to understand that SuperTokens stores email verification
	// status based on the user ID AND the email, and not just the email.
	isVerified, err := emailverification.IsEmailVerified(userId, &requestBody.Email)

	if err != nil {
		// TODO: handle error
	}

	if !isVerified {
		// Before sending a verification email, we check if the email is already
        // being used by another user. If it is, we throw an error.
		user, err := thirdpartyemailpassword.GetUserById(sessionContainer.GetUserID())

		if err != nil {
			// TODO: handle error
		}

		if user != nil {
			for i := 0; i < len(user.TenantIds); i++ {
				// Since once user can be shared across many tenants, we need to check if
				// the email already exists in any of the tenants.
				userWithEmail, err := thirdpartyemailpassword.GetUsersByEmail(user.TenantIds[i], requestBody.Email)
	
				if err != nil {
					// TODO: handle error
				}
	
				for j := 0; j < len(userWithEmail); j++ {
					if userWithEmail[j].ID != sessionContainer.GetUserID() {
						// TODO handle error, email already exists with another user.
						return
					}
				}
			}
		}

		// Now we create and send the email verification link to the user for the new email.
        _, err = emailverification.SendEmailVerificationEmail(sessionContainer.GetTenantId(), userId, &requestBody.Email)

        if err != nil {
            // TODO: handle error
        }

        return
	}

	// Since the email is verified, we try and do an update
    tenantId := "public"
	updateResponse, err := thirdpartyemailpassword.UpdateEmailOrPassword(userId, &requestBody.Email, nil, nil, &tenantId)

	if err != nil {
		// TODO: handle error
	}

	if updateResponse.OK != nil {
		// TODO: send successfully updated email response
		return
	}

	if updateResponse.EmailAlreadyExistsError != nil {
		// TODO: handle error, email already exists for another account
		return
	}

	log.Fatal("should not reach here")
	// highlight-end

}

func isValidEmail(email string) bool {
	emailCheck, err := regexp.Match(`^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$`, []byte(email))
	if err != nil {
		return false
	}
	return emailCheck
}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe.session.framework.flask import verify_session
from supertokens_python.recipe.session import SessionContainer
from supertokens_python.recipe.thirdpartyemailpassword.syncio import ( 
    get_user_by_id,
    update_email_or_password,
    get_users_by_email,
)
from supertokens_python.recipe.thirdpartyemailpassword.interfaces import (
    UpdateEmailOrPasswordOkResult,
    UpdateEmailOrPasswordEmailAlreadyExistsError,
)

from supertokens_python.recipe.emailverification.syncio import (
    is_email_verified,
    send_email_verification_email,
)

from flask import g, request, Flask
from re import fullmatch

app = Flask(__name__)

@app.route('/change-email', methods=['POST']) # type: ignore
@verify_session()
def change_email():
    # highlight-start
    session: SessionContainer = g.supertokens # type: ignore

    request_body = request.get_json()

    if request_body is None:
        # TODO: handle invalid body error
        return

    # validate the input email
    if not is_valid_email(request_body["email"]):
        # TODO: handle invalid email error
        return

    # check that the account is not a social account
    user_id = session.get_user_id()
    user_info = get_user_by_id(user_id)

    if user_info is None:
        # TODO handle error, user does not exist
        return

    if user_info.third_party_info is not None:
        # TODO handle error, cannot update email for social account
        return

    # Then, we check if the email is verified for this user ID or not.
    # It is important to understand that SuperTokens stores email verification
    # status based on the user ID AND the email, and not just the email.
    is_verified = is_email_verified(user_id, request_body["email"])
    
    if not is_verified:
        # Before sending a verification email, we check if the email is already
        # being used by another user. If it is, we throw an error.
        user = get_user_by_id(user_id)

        if user is not None:
            for tenant_id in user.tenant_ids:
                users_with_email = get_users_by_email(tenant_id, request_body["email"])

                for _user_with_email in users_with_email:
                    if _user_with_email.user_id != user_id:
                        # TODO handle error, email already exists with another user.
                        return
                    

        # Create and send the email verification link to the user for the new email.
        send_email_verification_email("public", user_id, request_body["email"])
        
        # TODO send successful email verification response
        return
    
    # update the users email
    update_response = update_email_or_password(user_id, email=request_body["email"])

    if isinstance(update_response, UpdateEmailOrPasswordOkResult):
        # TODO send successful email update response
        return

    if isinstance(update_response, UpdateEmailOrPasswordEmailAlreadyExistsError):
        # TODO handle error, email already exists
        return

    raise Exception("Should never reach here")
    # highlight-end


async def is_valid_email(value: str) -> bool:
    return (
        fullmatch(
            r'^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,'
            r"3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$",
            value,
        )
        is not None
    )
```

</TabItem>
</BackendSDKTabs>

</AppInfoForm>

<CustomAdmonition type="multi-tenancy">

- Notice that we loop through all the tenants that this user belongs to check that for each of the tenants, there is no other user with the new email. If we did not do this, then calling `updateEmailOrPassword` would fail because the email is already used by another user in one of the tenants that this user belongs to. So in that case, we do not want to go through the verification process either.
- We also pass in the tenantId of the current session when calling the `sendEmailVerificationEmail` function, so that the link generated will open the the tenant's UI that the user is currently interacting with.
- When calling `updateEmailOrPassword`, it will return `EMAIL_ALREADY_EXISTS_ERROR` if the new email exists in any of the tenants that the user ID is a part of.

</CustomAdmonition>


### Step 3: Override the `verifyEmailPost` API to update the user's account on successful email verification

- Update the accounts email on successful email verification.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import SuperTokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword";
import EmailVerification from "supertokens-node/recipe/emailverification";
import Session from "supertokens-node/recipe/session";

SuperTokens.init({
  appInfo: {
    apiDomain: "...",
    appName: "...",
    websiteDomain: "...",
  },
  recipeList: [
    ThirdPartyEmailPassword.init({}),
    EmailVerification.init({
        mode: "REQUIRED",
        override: {
            apis: (oI) => {
                return {
                    ...oI,
                    verifyEmailPOST: async function (input) {
                        // highlight-start
                        let response = await oI.verifyEmailPOST!(input);
                        if (response.status === "OK") {
                            // This will update the email of the user to the one
                            // that was just marked as verified by the token.
                            await ThirdPartyEmailPassword.updateEmailOrPassword({
                                recipeUserId: response.user.recipeUserId,
                                email: response.user.email,
                            });
                        }
                        return response;
                        // highlight-end
                    },
                };
            },
        },
    }),
    Session.init(),
  ],
});
```


</TabItem>

<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/emailverification"
	"github.com/supertokens/supertokens-golang/recipe/emailverification/evmodels"
	"github.com/supertokens/supertokens-golang/recipe/session"
	"github.com/supertokens/supertokens-golang/recipe/session/sessmodels"
	"github.com/supertokens/supertokens-golang/recipe/thirdpartyemailpassword"
	"github.com/supertokens/supertokens-golang/supertokens"
)

func test() {
	err := supertokens.Init(supertokens.TypeInput{
		AppInfo: supertokens.AppInfo{
			AppName:       "...",
			APIDomain:     "...",
			WebsiteDomain: "...",
		},
		RecipeList: []supertokens.Recipe{
			thirdpartyemailpassword.Init(nil),
			emailverification.Init(evmodels.TypeInput{
				Mode: evmodels.ModeRequired,
				Override: &evmodels.OverrideStruct{
					APIs: func(originalImplementation evmodels.APIInterface) evmodels.APIInterface {

						originalVerifyEmailPOST := *originalImplementation.VerifyEmailPOST

						(*originalImplementation.VerifyEmailPOST) = func(token string, sessionContainer sessmodels.SessionContainer, tenantId string, options evmodels.APIOptions, userContext supertokens.UserContext) (evmodels.VerifyEmailPOSTResponse, error) {
                            // highlight-start
							response, err := originalVerifyEmailPOST(token, sessionContainer, tenantId, options, userContext)
							if response.OK != nil {
								// This will update the email of the user to the one
								// that was just marked as verified by the token.
								_, err := thirdpartyemailpassword.UpdateEmailOrPassword(response.OK.User.ID, &response.OK.User.Email, nil, nil, &tenantId)
                                if err != nil {
									// TODO: Handle error
								}
							}

							return response, err
                            // highlight-end
						}

						return originalImplementation
					},
				},
			}),
			session.Init(nil),
		},
	})

	if err != nil {
		panic(err.Error())
	}
}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python import init, InputAppInfo, SupertokensConfig
from supertokens_python.recipe import thirdpartyemailpassword, emailverification
from supertokens_python.recipe.emailverification.interfaces import (
    APIInterface,
    APIOptions
)

from supertokens_python.recipe.thirdpartyemailpassword.asyncio import (
    update_email_or_password
)

from supertokens_python.recipe.emailverification.interfaces import (
    EmailVerifyPostOkResult
)

from supertokens_python.recipe.session.interfaces import (
    SessionContainer
)
from supertokens_python import (
    InputAppInfo,
    SupertokensConfig,
)

from typing import Optional, Dict, Any


def override_email_verification_apis(original_implementation: APIInterface):
    original_email_verification_verify_email_post = original_implementation.email_verify_post
    
    async def email_verify_post(
        token: str,
        session: Optional[SessionContainer],
        tenant_id: str,
        api_options: APIOptions,
        user_context: Dict[str, Any]
    ):

        # highlight-start
        verification_response = await original_email_verification_verify_email_post(token, session, tenant_id, api_options, user_context)
        
        if isinstance(verification_response, EmailVerifyPostOkResult):
            await update_email_or_password(verification_response.user.user_id, verification_response.user.email, tenant_id_for_password_policy=tenant_id)
        
        return verification_response
        # highlight-end
    
    original_implementation.email_verify_post = email_verify_post
    return original_implementation


init(
    supertokens_config=SupertokensConfig(
        connection_uri="..."
    ),
    app_info=InputAppInfo(api_domain="...", app_name="...", website_domain="..."),
    framework="flask",
    recipe_list=[
        thirdpartyemailpassword.init(),
        emailverification.init(
        "REQUIRED",
        override=emailverification.InputOverrideConfig(
            # highlight-start
            apis=override_email_verification_apis
            # highlight-end
        ),
    ),
    ],
)
```

</TabItem>
</BackendSDKTabs>