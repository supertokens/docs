---
id: thirdparty-login
title: Social login
hide_title: true
---

<!-- COPY SECTION -->
<!-- ./thirdpartyemailpassword/custom-ui/thirdparty-login.mdx -->
<!-- 1 -->

import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import TabItem from '@theme/TabItem';
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"
import AppInfoForm from "/src/components/appInfoForm"
import FrontendMobileSubTabs from "/src/components/tabs/FrontendMobileSubTabs"
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";

# Social login

There are different flows that the third party login provider may support:
- _**Flow 1)**_ Via authorisation code (one time use code) - for web and mobile apps. 
    - _**a)**_ If you have configred the client secret on the backend:
        - The frontend sends the auth code to the backend, the backend exchanges that with the provided client secret to get the access token. The access token is then used to fetch user info and log them in.
    - _**b)**_ If you have **not** provided the client secret on the backend:
        - The backend uses PKCE flow to exchange the auth code with the user's access token. The access token is then used to fetch user info and log them in.
- _**Flow 2)**_ Via OAuth / access tokens - for mobile apps.
    - The access token is available on the frontend and is sent to the backend. SuperTokens then fetches user info using the access token and logs them in.

:::note
The same flow applies during sign up and sign in. If the user is signing up, the `createdNewUser` boolean on the frontend and backend will be `true` (as the result of the sign in up API call).
:::

<FrontendCustomUITabs>
<TabItem value="web">

<h2>Flow 1a: Authorization code grant flow (Sign in with Google example)</h2>

<h3>Step 1) Redirecting to social / SSO provider</h3>

The first step is to fetch the URL on which the user will be authenticated. This can be done by querying the backend API exposed by SuperTokens (as shown below). The backend SDK automatically appends the right query params to the URL (like scope, client ID etc). 

After we get the URL, we simply redirect the user there. In the code below, we will take an example of login with Google:

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import { ^{webjsGetAuthorisationUrl} } from "supertokens-web-js/recipe/^{codeImportRecipeName}";

async function googleSignInClicked() {
    try {
        const authUrl = await ^{webjsGetAuthorisationUrl}({
            thirdPartyId: "google",

            // This is where Google should redirect the user back after login or error.
            // This URL goes on the Google's dashboard as well.
            frontendRedirectURI: "http://<YOUR_WEBSITE_DOMAIN>/auth/callback/google",
        });

        /*
        Example value of authUrl: https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email&access_type=offline&include_granted_scopes=true&response_type=code&client_id=1060725074195-kmeum4crr01uirfl2op9kd5acmi9jutn.apps.googleusercontent.com&state=5a489996a28cafc83ddff&redirect_uri=https%3A%2F%2Fsupertokens.io%2Fdev%2Foauth%2Fredirect-to-app&flowName=GeneralOAuthFlow
        */

        // we redirect the user to google for auth.
        window.location.assign(authUrl);
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokens^{recipeNameCapitalLetters} from "supertokens-web-js-script/recipe/^{codeImportRecipeName}";
async function googleSignInClicked() {
    try {
        const authUrl = await supertokens^{recipeNameCapitalLetters}.^{webjsGetAuthorisationUrl}({
            thirdPartyId: "google",

            // This is where Google should redirect the user back after login or error.
            // This URL goes on the Google's dashboard as well.
            frontendRedirectURI: "http://<YOUR_WEBSITE_DOMAIN>/auth/callback/google",
        });

        /*
        Example value of authUrl: https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email&access_type=offline&include_granted_scopes=true&response_type=code&client_id=1060725074195-kmeum4crr01uirfl2op9kd5acmi9jutn.apps.googleusercontent.com&state=5a489996a28cafc83ddff&redirect_uri=https%3A%2F%2Fsupertokens.io%2Fdev%2Foauth%2Fredirect-to-app&flowName=GeneralOAuthFlow
        */

        // we redirect the user to google for auth.
        window.location.assign(authUrl);
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
</NpmOrScriptTabs>

<h3>Step 2) Handling the auth callback on your frontend</h3>

Once the third party provider redirects your user back to your app, you need to consume the information to sign in the user. This requires you to:
- Setup a route in your app that will handle this callback. We recommend something like `http://<YOUR_WEBSITE_DOMAIN>/auth/callback/google` (for Google). Regardless of what you make this path, remember to use that same path when calling the `^{webjsGetAuthorisationUrl}` function in the first step.

- On that route, call the following function on page load

    <NpmOrScriptTabs>
    <TabItem value="npm">

    ```tsx
    import { ^{webjsThirdPartySignInUp} } from "supertokens-web-js/recipe/^{codeImportRecipeName}";

    async function handleGoogleCallback() {
        try {
            const response = await ^{webjsThirdPartySignInUp}();

            if (response.status === "OK") {
                console.log(response.user)
                if (response.createdNewRecipeUser && response.user.loginMethods.length === 1) {
                    // sign up successful
                } else {
                    // sign in successful
                }
                window.location.assign("/home");
            } else if (response.status === "SIGN_IN_UP_NOT_ALLOWED") {
                // the reason string is a user friendly message
                // about what went wrong. It can also contain a support code which users
                // can tell you so you know why their sign in / up was not allowed.
                window.alert(response.reason)
            } else {
                // SuperTokens requires that the third party provider
                // gives an email for the user. If that's not the case, sign up / in
                // will fail.

                // As a hack to solve this, you can override the backend functions to create a fake email for the user.

                window.alert("No email provided by social login. Please use another form of login");
                window.location.assign("/auth"); // redirect back to login page
            }
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    }
    ```

    </TabItem>
    <TabItem value="script">

    ```tsx
    import supertokens^{recipeNameCapitalLetters} from "supertokens-web-js-script/recipe/^{codeImportRecipeName}";
    async function handleGoogleCallback() {
        try {
            const response = await supertokens^{recipeNameCapitalLetters}.^{webjsThirdPartySignInUp}();

            if (response.status === "OK") {
                console.log(response.user)
                if (response.createdNewRecipeUser && response.user.loginMethods.length === 1) {
                    // sign up successful
                } else {
                    // sign in successful
                }
                window.location.assign("/home");
            } else if (response.status === "SIGN_IN_UP_NOT_ALLOWED") {
                // the reason string is a user friendly message
                // about what went wrong. It can also contain a support code which users
                // can tell you so you know why their sign in / up was not allowed.
                window.alert(response.reason)
            } else {
                // SuperTokens requires that the third party provider
                // gives an email for the user. If that's not the case, sign up / in
                // will fail.

                // As a hack to solve this, you can override the backend functions to create a fake email for the user.

                window.alert("No email provided by social login. Please use another form of login");
                window.location.assign("/auth"); // redirect back to login page
            }
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    }
    ```

    </TabItem>
    </NpmOrScriptTabs>    

:::note
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

<h3>Special case for login with Apple</h3>

<AppInfoForm
    askForWebsiteDomain
    askForAPIDomain
>

Unlike other providers, Apple will not redirect your user back to your frontend app. Instead, it will redirect the user to your backend with a `FORM POST` request. This means that the URL that you configure on the Apple's dashboard should point to your backend API layer in which **our middleware** will handle the request and redirect the user to your frontend app. Your frontend app should then call the `^{webjsThirdPartySignInUp}` API on that page as shown previously.

In order to tell SuperTokens which frontend route to redirect the user back to, you need to set the `frontendRedirectURI` to the frontend route (just like for other providers), and also need to set the `redirectURIOnProviderDashboard` to point to your backend API route (to which Apple will send a POST request).

<NpmOrScriptTabs>
<TabItem value="npm">

```tsx
import { ^{webjsGetAuthorisationUrl} } from "supertokens-web-js/recipe/^{codeImportRecipeName}";

async function appleSignInClicked() {
    try {
        const authUrl = await ^{webjsGetAuthorisationUrl}({
            thirdPartyId: "apple",

            frontendRedirectURI: "http://localhost:3000/auth/callback/apple", // This is an example callback URL on your frontend. You can use another path as well.
            // highlight-start
            redirectURIOnProviderDashboard: "^{form_apiDomain}^{form_apiBasePath}/callback/apple", // This URL goes on the Apple's dashboard
            // highlight-end
        });

        // we redirect the user to apple for auth.
        window.location.assign(authUrl);
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
<TabItem value="script">

```tsx
import supertokens^{recipeNameCapitalLetters} from "supertokens-web-js-script/recipe/^{codeImportRecipeName}";
async function appleSignInClicked() {
    try {
        const authUrl = await supertokens^{recipeNameCapitalLetters}.^{webjsGetAuthorisationUrl}({
            thirdPartyId: "apple",

            frontendRedirectURI: "http://localhost:3000/auth/callback/apple", // This is an example callback URL on your frontend. You can use another path as well.
            // highlight-start
            redirectURIOnProviderDashboard: "^{form_apiDomain}^{form_apiBasePath}/callback/apple", // This URL goes on the Apple's dashboard
            // highlight-end
        });

        /*
        Example value of authUrl: https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email&access_type=offline&include_granted_scopes=true&response_type=code&client_id=1060725074195-kmeum4crr01uirfl2op9kd5acmi9jutn.apps.googleusercontent.com&state=5a489996a28cafc83ddff&redirect_uri=https%3A%2F%2Fsupertokens.io%2Fdev%2Foauth%2Fredirect-to-app&flowName=GeneralOAuthFlow
        */

        // we redirect the user to google for auth.
        window.location.assign(authUrl);
    } catch (err: any) {
        if (err.isSuperTokensGeneralError === true) {
            // this may be a custom error message sent from the API by you.
            window.alert(err.message);
        } else {
            window.alert("Oops! Something went wrong.");
        }
    }
}
```

</TabItem>
</NpmOrScriptTabs>

</AppInfoForm>

<h2>Flow 1b: Authorization code grant flow with PKCE</h2>

This is identical to flow 1a, except that you do **not** need to provide a client secret during backend init. This flow only works for providers which support the [PKCE flow](https://oauth.net/2/pkce/).

<h2>Flow 2: Via OAuth / Access token</h2>

:::caution
This flow is not applicable for web apps.
:::

</TabItem>

<TabItem value="mobile">

<h2>Flow 1a: Authorization code grant flow</h2>

<h3>Sign in with Apple example</h3>

<FrontendMobileSubTabs>

<TabItem value="reactnative">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

For react native apps, this involves setting up the [react-native-apple-authentication library](https://github.com/invertase/react-native-apple-authentication) in your app. Checkout their `README` for steps on how to integrate their SDK into your application. The minimum scope required by SuperTokens is the one that gives the user's email (In case of Apple, that could be the user's actual email or the proxy email provided by Apple - it doesn't really matter).

Once the integration is done, you should call the `appleAuth.performRequest` function for iOS and the `appleAuthAndroid.signIn` function for Android. Either way, the result of the function will be a one time use auth code which you should send to your backend as shown in the next step.

A full example of this can be found in [our example app](https://github.com/supertokens/supertokens-react-native/blob/master/examples/with-thirdparty/apple.ts).

In case you are using Expo, you can use the [expo-apple-authentication](https://docs.expo.dev/versions/latest/sdk/apple-authentication/) library instead (not that this library only works on iOS).

</TabItem>

<TabItem value="android">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

:::info
Coming Soon
:::

</TabItem>

<TabItem value="ios">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

For iOS you use the normal sign in with apple flow and then use the authorization code to login with SuperTokens. You can see a full example of this in the `onAppleClicked` function in [our example app](https://github.com/supertokens/supertokens-ios/blob/master/examples/with-thirdparty/with-thirdparty/LoginScreen/LoginScreenViewController.swift).

```swift
import UIKit
import AuthenticationServices

fileprivate class ViewController: UIViewController, ASAuthorizationControllerPresentationContextProviding, ASAuthorizationControllerDelegate {
    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
        return view.window!
    }

    func loginWithApple() {
        let authorizationRequest = ASAuthorizationAppleIDProvider().createRequest()
        authorizationRequest.requestedScopes = [.email, .fullName]
        
        let authorizationController = ASAuthorizationController(authorizationRequests: [authorizationRequest])
        
        authorizationController.presentationContextProvider = self
        authorizationController.delegate = self
        authorizationController.performRequests()
    }
    
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        guard let credential: ASAuthorizationAppleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential,
            let authorizationCode = credential.authorizationCode,
            let authorizationCodeString: String = String(data: authorizationCode, encoding: .utf8),
            let email: String = credential.email as? String,
            let nameComponents: PersonNameComponents = credential.fullName as? PersonNameComponents,
            let firstName: String = nameComponents.givenName as? String,
            let lastName: String = nameComponents.familyName as? String else {return}
        
        // Send the user information and auth code to the backend. Refer to the next step.
    }
}
```

</TabItem>

<TabItem value="flutter">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

For flutter we use the [sign_in_with_apple](https://pub.dev/packages/sign_in_with_apple) package, make sure to follow the prerequisites steps to get the package setup. After setup use the snippet below to trigger the apple sign in flow. You can see a full example of this in the `loginWithApple` function in [our example app](https://github.com/supertokens/supertokens-flutter/blob/master/examples/with-thirdparty/lib/screens/login.dart).

```dart
import 'package:sign_in_with_apple/sign_in_with_apple.dart';

void loginWithApple() async {
  try {
    var credential = await SignInWithApple.getAppleIDCredential(
        scopes: [
            AppleIDAuthorizationScopes.email,
            AppleIDAuthorizationScopes.fullName,
        ],
        // Required for Android only
        webAuthenticationOptions: WebAuthenticationOptions(
            clientId: "<CLIENT_ID>",
            redirectUri: Uri.parse(
            "<API_DOMAIN>/<API_BASE_PATH>/callback/apple",
            ),
        ),
    );

    String authorizationCode = credential.authorizationCode;
    String? idToken = credential.identityToken;
    String? email = credential.email;
    String? firstname = credential.givenName;
    String? lastName = credential.familyName;

    // Send the user information and auth code to the backend. Refer to the next step.
  } catch (e) {
    // Sign in aborted or failed
  }
}
```

In the snippet above for Android we need to pass an additional `webAuthenticationOptions` property when signing in with Apple. This is because on Android the library uses the web login flow and we need to provide it with the client id and redirection uri. The `redirectUri` property here is the URL to which Apple will make a `POST` request after the user has logged in. The SuperTokens backend SDKs provide an API for this at `<API_DOMAIN>/<API_BASE_PATH>/callback/apple`.

<h4> Additional steps for Android </h4>

For android we also need to provide a way for the web login flow to redirect back to the app. By default the API provided by the backend SDKs redirect to the website domain you provide when initialising the SDK, we can override the API to have it redirect to our app instead. For example if you were using the Node.js SDK:

<BackendSDKTabs>

<TabItem value="nodejs">

```tsx
import ^{recipeNameCapitalLetters} from "supertokens-node/recipe/^{codeImportRecipeName}";

^{recipeNameCapitalLetters}.init({
    // highlight-start
    override: {
        apis: (original) => {
            return {
                ...original,
                appleRedirectHandlerPOST: async (input) => {
                    if (original.appleRedirectHandlerPOST === undefined) {
                        throw Error("Should never come here");
                    }

                    // inut.formPostInfoFromProvider contains all the query params attached by Apple
                    const stateInBase64 = input.formPostInfoFromProvider.state;

                    // The web SDKs add a default state
                    if (stateInBase64 === undefined) {
                        // Redirect to android app
                        // We create a dummy URL to create the query string
                        const dummyUrl = new URL("http://localhost:8080");
                        for (const [key, value] of Object.entries(input.formPostInfoFromProvider)) {
                            dummyUrl.searchParams.set(key, `${value}`);
                        }

                        const queryString = dummyUrl.searchParams.toString();
                        // Refer to the README of sign_in_with_apple to understand what this url is
                        const redirectUrl = `intent://callback?${queryString}#Intent;package=YOUR.PACKAGE.IDENTIFIER;scheme=signinwithapple;end`;

                        input.options.res.setHeader("Location", redirectUrl, false);
                        input.options.res.setStatusCode(303);
                        input.options.res.sendHTMLResponse("");
                    } else {
                        // For the web flow we can use the original implementation
                        original.appleRedirectHandlerPOST(input);
                    }
                },
            };
        },
    },
    // highlight-end
    ^{nodeRecipeInitDefault}
})
```

</TabItem>

<TabItem value="go">

```go
import (
	"net/http"
	"strings"

	"github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}"
    ^{goTPModelsImport}
	"github.com/supertokens/supertokens-golang/recipe/^{codeImportRecipeName}/^{goModelName}"
)

func main() {
	^{codeImportRecipeName}.Init(^{goModelNameForInit}.TypeInput{
		Override: &^{goModelName}.OverrideStruct{
            // highlight-start
			APIs: func(originalImplementation ^{goModelName}.APIInterface) ^{goModelName}.APIInterface {
				originalAppleRedirectPost := *originalImplementation.AppleRedirectHandlerPOST

				*originalImplementation.AppleRedirectHandlerPOST = func(formPostInfoFromProvider map[string]interface{}, options tpmodels.APIOptions, userContext *map[string]interface{}) error {
					// formPostInfoFromProvider contains all the query params attached by Apple
					state, stateOk := formPostInfoFromProvider["state"].(string)

					queryParams := []string{}
					if (!stateOk) || state == "" { 
						// Redirect to android app
						for key, value := range formPostInfoFromProvider {
							queryParams = append(queryParams, key+"="+value.(string))
						}

						queryString := ""
						if len(queryParams) > 0 {
							queryString = strings.Join(queryParams, "&")
						}

						// Refer to the README of sign_in_with_apple to understand what this url is
						redirectUri := "intent://callback?" + queryString + "#Intent;package=YOUR.PACKAGE.IDENTIFIER;scheme=signinwithapple;end"

						options.Res.Header().Set("Location", redirectUri)
						options.Res.WriteHeader(http.StatusSeeOther)
						return nil
					} else {
						return originalAppleRedirectPost(formPostInfoFromProvider, options, userContext)
					}
				}

				return originalImplementation
			},
		},
        // highlight-end
		^{goSignInUpFeatureStart}
			Providers: []tpmodels.ProviderInput{
				// ...
			},
		^{goSignInUpFeatureEnd}
	})
}
```

</TabItem>

<TabItem value="python">

```python
from supertokens_python.recipe import ^{codeImportRecipeName}
from supertokens_python.recipe.^{codeImportRecipeName}.interfaces import APIInterface, ^{pythonThirdPartyAPIOptions}
from typing import Dict, Any

# highlight-start
def override_thirdparty_apis(original_implementation: APIInterface):
    original_apple_redirect_post = original_implementation.apple_redirect_handler_post

    async def apple_redirect_handler_post(
        form_post_info: Dict[str, Any],
        api_options: ^{pythonThirdPartyAPIOptions},
        user_context: Dict[str, Any]
    ):
        # form_post_info contains all the query params attached by Apple
        state = form_post_info["state"]

        # The web SDKs add a default state
        if state is None:
            query_items = [
                f"{key}={value}" for key, value in form_post_info.items()
            ]

            query_string = "&".join(query_items)

            # Refer to the README of sign_in_with_apple to understand what this url is
            redirect_url = f"intent://callback?${query_string}#Intent;package=YOUR.PACKAGE.IDENTIFIER;scheme=signinwithapple;end"

            api_options.response.set_header("Location", redirect_url)
            api_options.response.set_status_code(303)
            api_options.response.set_html_content("")
        else:
            return await original_apple_redirect_post(form_post_info, api_options, user_context)

    original_implementation.apple_redirect_handler_post = apple_redirect_handler_post
    return original_implementation
# highlight-end

^{codeImportRecipeName}.init(
    # highlight-start
    override=^{codeImportRecipeName}.InputOverrideConfig(
        apis=override_thirdparty_apis
    ),
    # highlight-end
    ^{pythonRecipeInitDefault}
)
```

</TabItem>

</BackendSDKTabs>

In the code above we override the `appleRedirectHandlerPOST` API to check if the request was made by our Android app (You can skip checking the state if you only have a mobile app and no website). `sign_in_with_apple` requires us to parse the query params sent by apple and include them in the redirect URL in a specific way, and then we simply redirect to the deep link url. Refer to the README for `sign_in_with_apple` to read about the deep link setup required in Android.

</TabItem>

</FrontendMobileSubTabs>

<h4>Step 2) Calling the signinup API to consume the authorisation token</h4>

<AppInfoForm askForAPIDomain showMultiTenancyTab>

Once you have the authorisation code from the auth provider, you need to call the signinup API exposed by our backend SDK as shown below:

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/signinup' \
--header 'rid: ^{codeImportRecipeName}' \
--header 'Content-Type: application/json; charset=utf-8' \
--data-raw '{
    "thirdPartyId": "apple",
    "clientType": "...",
    "redirectURIInfo": {
        "redirectURIOnProviderDashboard": "^{form_apiDomain}^{form_apiBasePath}/callback/apple",
        "redirectURIQueryParams": {
            "code": "...",
            "user": {
                "name":{
                    "firstName":"...",
                    "lastName":"..."
                },
                "email":"..."
            }
        }
    }
}'
```

:::important
- On iOS, the client id set in the backend should be the same as the bundle identifier for your app.
- The `clientType` input is optional, and is required only if you have initialised more than one client in the provide on the backend (See the "Social / SSO login for both, web and mobile apps" section below).
- On iOS, `redirectURIOnProviderDashboard` doesn't matter and its value can be a universal link configured for your app.
- On Android, the `redirectURIOnProviderDashboard` should match the one configured on the Apple developer dashboard.
- The `user` object contains information provided by Apple.
:::

The response body from the API call has a `status` property in it:
- `status: "OK"`: User sign in / up was successful. The response also contains more information about the user, for example their user ID, and if it was a new user or existing user.
- `status: "NO_EMAIL_GIVEN_BY_PROVIDER"`: This is returned if the social / SSO provider did not provider an email for the user. In this case, you want to ask the user to pick another method of sign in. Or, you can also override the backend functions to create a fake email for the user for this provider.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.
- `status: "SIGN_IN_UP_NOT_ALLOWED"`: This can happen during automatic account linking or during MFA. The `reason` prop that's in the response body contains a support code using which you can see why the sign in / up was not allowed.

:::note
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

</AppInfoForm>

<h3>Sign in with Google Example</h3>

<FrontendMobileSubTabs>

<TabItem value="reactnative">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

This involves setting up the [@react-native-google-signin/google-signin](https://github.com/react-native-google-signin/google-signin) in your app. Checkout their `README` for steps on how to integrate their SDK into your application. The minimum scope required by SuperTokens is the one that gives the user's email.

Once the library is set up, use `GoogleSignin.configure` and  `GoogleSignin.signIn` to trigger the login flow and sign the user in with Google. Refer to [our example app](https://github.com/supertokens/supertokens-react-native/blob/master/examples/with-thirdparty/google.ts) to see the full code for this.

```tsx
import { GoogleSignin } from "@react-native-google-signin/google-signin";

export const performGoogleSignIn = async (): Promise<boolean> => {
  GoogleSignin.configure({
    webClientId: "GOOGLE_WEB_CLIENT_ID",
    iosClientId: "GOOGLE_IOS_CLIENT_ID",
  });

  try {
    const user = await GoogleSignin.signIn({});
    const authCode = user.serverAuthCode;

    // Refer to step 2

    return true;
  } catch (e) {
    console.log("Google sign in failed with error", e);
  }

  return false;
};
```

</TabItem>

<TabItem value="android">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

Follow the [official Google Sign In guide](https://developers.google.com/identity/sign-in/android/start-integrating) to set up their library and sign the user in with Google. Fetch the authorization code from the google sign in result. For a full example refer to the `signInWithGoogle` function in [our example app](https://github.com/supertokens/supertokens-android/blob/master/examples/with-thirdparty/app/src/main/java/com/supertokens/supertokensexample/LoginActivity.kt).

```kotlin
import androidx.activity.result.ActivityResult
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import android.content.Intent

class LoginActivity : AppCompatActivity() {
    private lateinit var googleResultLauncher: ActivityResultLauncher<Intent>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        googleResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {
            onGoogleResultReceived(it)
        }
    }

    private fun signInWithGoogle() {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestServerAuthCode("GOOGLE_WEB_CLIENT_ID")
            .requestEmail()
            .build()

        val googleClient = GoogleSignIn.getClient(this, gso)
        val signInIntent = googleClient.signInIntent

        googleResultLauncher.launch(signInIntent)
    }

    private fun onGoogleResultReceived(it: ActivityResult) {
        val task = GoogleSignIn.getSignedInAccountFromIntent(it.data)
        val account = task.result
        val authCode = account.serverAuthCode

        // Refer to step 2
    }
}
```

</TabItem>

<TabItem value="ios">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

For iOS we use the `GoogleSignIn` library, follow the [official guide](https://developers.google.com/identity/sign-in/ios/start-integrating) to set up the library and sign the user in with Google. Use the result of google sign in to get the authorization code. For a full example refer to the `onGoogleCliked` function in [our example app](https://github.com/supertokens/supertokens-ios/blob/master/examples/with-thirdparty/with-thirdparty/LoginScreen/LoginScreenViewController.swift).

```swift
import UIKit
import GoogleSignIn

fileprivate class LoginScreenViewController: UIViewController {
    @IBAction func onGoogleCliked() {
        GIDSignIn.sharedInstance.signIn(withPresenting: self) { signInResult, error in
            guard error == nil else { return }

            guard let authCode: String = signInResult?.serverAuthCode as? String else {
                print("Google login did not return an authorisation code")
                return
            }
            
            // Refer to step 2
        }
    }
}
```

</TabItem>

<TabItem value="flutter">

<h4>Step 1) Fetching the authorisation token on the frontend</h4>

For flutter we use the [google_sign_in](https://pub.dev/packages/google_sign_in) package, make sure to follow the prerequisites steps to get the package setup. After setup use the snippet below to trigger the google sign in flow. For a full example refer to the `loginWithGoogle` in [our example app](https://github.com/supertokens/supertokens-flutter/blob/master/examples/with-thirdparty/lib/screens/login.dart).

```dart
import 'package:google_sign_in/google_sign_in.dart';
import 'dart:io';

Future<void> loginWithGoogle() async {
    GoogleSignIn googleSignIn;

    if (Platform.isAndroid) {
      googleSignIn = GoogleSignIn(
        serverClientId: "GOOGLE_WEB_CLIENT_ID",
        scopes: [
          'email',
        ],
      );
    } else {
      googleSignIn = GoogleSignIn(
        clientId: "GOOGLE_IOS_CLIENT_ID",
        serverClientId: "GOOGLE_WEB_CLIENT_ID",
        scopes: [
          'email',
        ],
      );
    }

    GoogleSignInAccount? account = await googleSignIn.signIn();

    if (account == null) {
        print("Google sign in was aborted");
        return;
    }

    String? authCode = account.serverAuthCode;

    if (authCode == null) {
        print("Google sign in did not return a server auth code");
        return;
    }

    // Refer to step 2
  }
```

</TabItem>

</FrontendMobileSubTabs>

<h4>Step 2) Calling the signinup API to consume the authorisation token</h4>

<AppInfoForm askForAPIDomain showMultiTenancyTab>

Once you have the authorisation code from the auth provider, you need to call the signinup API exposed by our backend SDK as shown below:

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/signinup' \
--header 'rid: ^{codeImportRecipeName}' \
--header 'Content-Type: application/json; charset=utf-8' \
--data-raw '{
    "thirdPartyId": "google",
    "clientType": "...",
    "redirectURIInfo": {
        "redirectURIOnProviderDashboard": "",
        "redirectURIQueryParams": {
            "code": "...",
        }
    }
}'
```

:::important
When calling the API exposed by the SuperTokens backend SDK, we pass an empty string for `redirectURIOnProviderDashboard` because we use the native login flow using the authorization code which does not involve any redirection on the frontend.
:::

The response body from the API call has a `status` property in it:
- `status: "OK"`: User sign in / up was successful. The response also contains more information about the user, for example their user ID, and if it was a new user or existing user.
- `status: "NO_EMAIL_GIVEN_BY_PROVIDER"`: This is returned if the social / SSO provider did not provider an email for the user. In this case, you want to ask the user to pick another method of sign in. Or, you can also override the backend functions to create a fake email for the user for this provider.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.
- `status: "SIGN_IN_UP_NOT_ALLOWED"`: This can happen during automatic account linking or during MFA. The `reason` prop that's in the response body contains a support code using which you can see why the sign in / up was not allowed.

:::note
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

</AppInfoForm>

<h2>Flow 1b: Authorization code grant flow with PKCE</h2>

This is similar to flow 1a, except that you do **not** need to provide a client secret during backend init. This flow only works for providers which support the [PKCE flow](https://oauth.net/2/pkce/).

<FrontendMobileSubTabs>

<TabItem value="reactnative">

<h3>Step 1) Fetching the authorisation token on the frontend</h3>

You can use the [react native auth library](https://github.com/FormidableLabs/react-native-app-auth) to also return the PKCE code verifier along with the authorization code. This can be done by setting the `usePKCE` boolean to `true` and also by setting the `skipCodeExchange` to `true` when configuring the react native auth library.

</TabItem>

<TabItem value="android">

<h3>Step 1) Fetching the authorisation token on the frontend</h3>

You can use the [AppAuth-Android](https://github.com/openid/AppAuth-Android) library to use the PKCE flow by using the `setCodeVerifier` method when creating a `AuthorizationRequest`.

</TabItem>

<TabItem value="ios">

<h3>Step 1) Fetching the authorisation token on the frontend</h3>

You can use the [AppAuth-iOS](https://github.com/openid/AppAuth-iOS) library to use the PKCE flow.

</TabItem>

<TabItem value="flutter">

<h3>Step 1) Fetching the authorisation token on the frontend</h3>

You can use [flutter_appauth](https://pub.dev/packages/flutter_appauth) to use the PKCE flow by providing a `codeVerifier` when you call the `appAuth.token` function.

</TabItem>

</FrontendMobileSubTabs>

<h3>Step 2) Calling the signinup API to consume the authorisation token</h3>

<AppInfoForm askForAPIDomain showMultiTenancyTab>

Once you have the authorisation code and PKCE verifier from the auth provider, you need to call the signinup API exposed by our backend SDK as shown below:

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/signinup' \
--header 'rid: ^{codeImportRecipeName}' \
--header 'Content-Type: application/json' \
--data-raw '{
    "thirdPartyId": "THIRD_PARTY_ID",
    "clientType": "...",
    "redirectURIInfo": {
        "redirectURIOnProviderDashboard": "REDIRECT_URI",
        "redirectURIQueryParams": {
            "code": "...",
        },
        "pkceCodeVerifier": "..."
    }
}'
```

:::important
- Replace `THIRD_PARTY_ID` with the provider id. The provider id must match the one you configure in the backend when intialising SuperTokens.
- `REDIRECT_URI` must exactly match the value you configure on the providers dashboard.
:::

The response body from the API call has a `status` property in it:
- `status: "OK"`: User sign in / up was successful. The response also contains more information about the user, for example their user ID, and if it was a new user or existing user.
- `status: "NO_EMAIL_GIVEN_BY_PROVIDER"`: This is returned if the social / SSO provider did not provider an email for the user. In this case, you want to ask the user to pick another method of sign in. Or, you can also override the backend functions to create a fake email for the user for this provider.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.
- `status: "SIGN_IN_UP_NOT_ALLOWED"`: This can happen during automatic account linking or during MFA. The `reason` prop that's in the response body contains a support code using which you can see why the sign in / up was not allowed.

:::note
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

</AppInfoForm>

----------------

<h2>Flow 2: Via OAuth / Access token</h2>

<h3>Step 1) Fetching the OAuth / access tokens on the frontend</h3>

1. Sign in with the social provider. The minimum required scope is the one that provides access to the user's email. You can use any library to sign in with the social provider.
2. Get the access token on the frontend if it is available.
3. Get the id token from the sign in result if it is available.

:::important
You need to provide either the access token or the id token, or both in step 2, depending on what is available.
:::

<h3>Step 2) Calling the signinup API to use the OAuth tokens</h3>

<AppInfoForm askForAPIDomain showMultiTenancyTab>

Once you have the `access_token` or the `id_token` from the auth provider, you need to call the signinup API exposed by our backend SDK as shown below:

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/signinup' \
--header 'rid: ^{codeImportRecipeName}' \
--header 'Content-Type: application/json; charset=utf-8' \
--data-raw '{
    "thirdPartyId": "google",
    "clientType": "...",
    "oAuthTokens": {
        "access_token": "...",
        "id_token": "..."
    },
}'
```

:::important
- The `clientType` input is optional, and is required only if you have initialised more than one client in the provide on the backend (See the "Social / SSO login for both, web and mobile apps" section below).
- If you have the `id_token`, you can send that along with the `access_token`.
:::

The response body from the API call has a `status` property in it:
- `status: "OK"`: User sign in / up was successful. The response also contains more information about the user, for example their user ID, and if it was a new user or existing user.
- `status: "NO_EMAIL_GIVEN_BY_PROVIDER"`: This is returned if the social / SSO provider did not provider an email for the user. In this case, you want to ask the user to pick another method of sign in. Or, you can also override the backend functions to create a fake email for the user for this provider.
- `status: "GENERAL_ERROR"`: This is only possible if you have overriden the backend API to send back a custom error message which should be displayed on the frontend.
- `status: "SIGN_IN_UP_NOT_ALLOWED"`: This can happen during automatic account linking or during MFA. The `reason` prop that's in the response body contains a support code using which you can see why the sign in / up was not allowed.

:::note
On success, the backend will send back session tokens as part of the response headers which will be automatically handled by our frontend SDK for you.
:::

</AppInfoForm>

</TabItem>

</FrontendCustomUITabs>

## Social / SSO login for both, web and mobile apps

If you have social / SSO login for your web and mobile app, then you might need to setup different client ID / secret for the same provider on the backend. For example, in case of Apple login, Apple gives you different client IDs for iOS login vs web & Android login (same client ID for web and Android).

In order to get this to work, you would need to add additional clients to the Apple.init on the backend. Each client would need to be uniquely identified and this is done using the `clientType` string. For example, you can add one `clientType` for `web-and-android` and one for `ios`.

<BackendSDKTabs>
<TabItem value="nodejs">

```tsx
import { ^{nodeProviderInput} } from "supertokens-node/recipe/^{codeImportRecipeName}/types";

let providers: ^{nodeProviderInput}[] = [
    {
        config: {
            thirdPartyId: "apple",
            clients: [{
                clientType: "web-and-android",
                clientId: "...",
                additionalConfig: {
                    "keyId": "...",
                    "privateKey": "...",
                    "teamId": "...",
                }
            }, {
                clientType: "ios",
                clientId: "...",
                additionalConfig: {
                    "keyId": "...",
                    "privateKey": "...",
                    "teamId": "...",
                }
            }]
        }
    }
]
```

</TabItem>
<TabItem value="go">

```go
import (
	"github.com/supertokens/supertokens-golang/recipe/thirdparty/tpmodels"
)

func main() {
	_ = []tpmodels.ProviderInput{{
		Config: tpmodels.ProviderConfig{
			ThirdPartyId: "apple",
			Clients: []tpmodels.ProviderClientConfig{
				{
					ClientType: "web-and-android",
					ClientID:   "...",
					AdditionalConfig: map[string]interface{}{
						"keyId":      "...",
						"privateKey": "...",
						"teamId":     "...",
					},
				},
				{
					ClientType: "ios",
					ClientID:   "...",
					AdditionalConfig: map[string]interface{}{
						"keyId":      "...",
						"privateKey": "...",
						"teamId":     "...",
					},
				},
			},
		},
	}}
}
```

</TabItem>
<TabItem value="python">

```python
from supertokens_python.recipe.thirdparty.provider import ProviderInput, ProviderConfig, ProviderClientConfig

providers = [
    ProviderInput(
        config=ProviderConfig(
            third_party_id="apple",
            clients=[
                ProviderClientConfig(
                    client_type="web-and-android",
                    client_id="...",
                    additional_config={
                        "keyId":      "...",
                        "privateKey": "...",
                        "teamId":     "...",
                    },
                ),
                ProviderClientConfig(
                    client_type="ios",
                    client_id="...",
                    additional_config={
                        "keyId":      "...",
                        "privateKey": "...",
                        "teamId":     "...",
                    },
                ),
            ],
        ),
    ),
]
```

</TabItem>
</BackendSDKTabs>

For the frontend, you would need to use the right `clientType` as shown below:

<FrontendCustomUITabs>
<TabItem value="web">

<NpmOrScriptTabs>
<TabItem value="npm">

<AppInfoForm askForAPIDomain askForWebsiteDomain>

We pass in the `clientType` during the init call.

```tsx
import SuperTokens from 'supertokens-web-js';

SuperTokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    // highlight-next-line
    clientType: "web-and-android",
    recipeList: [/*...*/],
});
```

If you are using our pre built UI SDK (supertokens-auth-react) as well, you can provide the `clientType` config to it as follows:

```tsx
import SuperTokens from 'supertokens-auth-react';

SuperTokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        websiteDomain: "^{form_websiteDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    // highlight-next-line
    clientType: "web-and-android",
    recipeList: [/*...*/],
});
```

</AppInfoForm>

</TabItem>
<TabItem value="script">

<AppInfoForm askForAPIDomain>

We pass in the `clientType` during the init call.

```tsx
import supertokens from "supertokens-web-js-script";
supertokens.init({
    appInfo: {
        apiDomain: "^{form_apiDomain}",
        apiBasePath: "^{form_apiBasePath}",
        appName: "...",
    },
    // highlight-next-line
    clientType: "web-and-android",
    recipeList: [/*...*/],
});
```

</AppInfoForm>

</TabItem>
</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

When making calls to the APIs from your mobile app, the request body also takes a `clientType` prop as seen in the above API calls.

</TabItem>
</FrontendCustomUITabs>

<!-- END COPY SECTION -->

## See also

- [Post sign in / sign up action](../common-customizations/handling-signinup-success)
- [See all built in providers](../common-customizations/sign-in-and-up/built-in-providers)
- [Changing OAuth provider's scope](../common-customizations/sign-in-and-up/built-in-providers#setting-oauth-scopes)
- [Integrating with a custom OAuth provider](../common-customizations/sign-in-and-up/custom-providers)
- [Fetching profile info and using the provider's access token on the backend](../common-customizations/get-user-info)
- [Customising user ID format](../common-customizations/userid-format)
