---
id: totp-for-all-users
title: TOTP required for all users
hide_title: true
show_ui_switcher: true
---

import MFAPaidBanner from '../../community/reusableMD/mfa/MFAPaidBanner.mdx'
import BackendSDKTabs from "/src/components/tabs/BackendSDKTabs";
import TabItem from '@theme/TabItem';
import PythonSyncAsyncSubTabs from "/src/components/tabs/PythonSyncAsyncSubTabs";
import CoreInjector from "/src/components/coreInjector"
import CustomAdmonition from "/src/components/customAdmonition"
import {Question, Answer}from "/src/components/question"
import FrontendPreBuiltUITabs from "/src/components/tabs/FrontendPreBuiltUITabs"
import {PreBuiltOrCustomUISwitcher, PreBuiltUIContent, CustomUIContent} from "/src/components/preBuiltOrCustomUISwitcher"
import FrontendCustomUITabs from "/src/components/tabs/FrontendCustomUITabs"
import NpmOrScriptTabs from "/src/components/tabs/NpmOrScriptTabs"
import AppInfoForm from "/src/components/appInfoForm"
import FrontendMobileSubTabs from "/src/components/tabs/FrontendMobileSubTabs"

<MFAPaidBanner />

# TOTP required for all users

In this page, we will show you how to implement an MFA policy that requires all users to use TOTP before they get access to your application.

:::note
We assume that the first factor is [email password or social login](/docs/thirdpartyemailpassword/introduction), but the same set of steps will be applicable for other first factor types as well.
:::

## Single tenant setup

### Backend setup
To start with, we configure the backend in the following way:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword"
import MultiFactorAuth from "supertokens-node/recipe/multifactorauth"
import totp from "supertokens-node/recipe/totp"
import Session from "supertokens-node/recipe/session"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init(),
        ThirdPartyEmailPassword.init({
            //...
        }),
        // highlight-next-line
        totp.init(),
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"],
            // highlight-start
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getMFARequirementsForAuth: async function (input) {
                            return ["totp"]
                        }
                    }
                }
            }
            // highlight-end
        })
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon.
:::

</TabItem>
</BackendSDKTabs>

- Notice that we have initialised the TOTP recipe in the `recipeList`. By default, no configs are required for it, but you can provide:
    - `issuer`: This is the name that will show up in the TOTP app for the user. By default, this is equal to the `appName` config, however, you can change it to something else using this property.
    - `defaultSkew`: The default value of this is `1`, which means that TOTP codes that were generated 1 tick before, and that will be generated 1 tick after from the current tick will be accepted at any given time (including the TOTP of the current tick, of course).
    -  `defaultPeriod`: The default value of this is `30`, which means that the current tick is valie for 30 seconds. So by default, a TOTP code that's just shown to the user, is valid for 60 seconds (`defaultPeriod + defaultSkew*defaultPeriod` seconds)
- We also override the `getMFARequirementsForAuth` function to indicate that `totp` must be completed before the user can access the app. Notice that we do not check for the userId there, and return `totp` for all users.

Once the user finishes the first factor (for example, with emailpassword), their session access token payload will look like this:
```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
        },
        "v": false
    }
}
```

The `v` being `false` indicates that there are still factors that are pending. After the user has finished totp, the payload will look like:

```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
            "totp": 1702877999
        },
        "v": true
    }
}
```

Indicating that the user has finished all required factors, and should be allowed to access the app.

### Frontend setup

<PreBuiltOrCustomUISwitcher>

<PreBuiltUIContent>

We start by modifying the `init` function call on the frontend like so:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import Passwordless from "supertokens-auth-react/recipe/passwordless"
import MultiFactorAuth from "supertokens-auth-react/recipe/multifactorauth"
import totp from "supertokens-auth-react/recipe/totp"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    recipeList: [
        ThirdPartyEmailPassword.init( /* ... */),
        // highlight-start
        totp.init(),
        MultiFactorAuth.init({
            firstFactors: ["emailpassword", "thirdparty"]
        })
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

- Just like on the backend, we init the `totp` recipe in the `recipeList`.
- We also init the `MultiFactorAuth` recipe, and pass in the first factors that we want to use. In this case, that would be `emailpassword` and `thirdparty` - same as the backend.

Next, we need to add the TOTP pre built UI when rendering the SuperTokens component:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

<Question
    question="Do you use react-router-dom?">
<Answer title="Yes">

```tsx
import { SuperTokensWrapper } from "supertokens-auth-react";
import { getSuperTokensRoutesForReactRouterDom } from "supertokens-auth-react/ui";
import { ThirdPartyEmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/thirdpartyemailpassword/prebuiltui"; 
import { TOTPPreBuiltUI } from "supertokens-auth-react/recipe/totp/prebuiltui";
import reactRouterDOM, { Routes, BrowserRouter as Router, Route } from "react-router-dom";

function App() {
  return (
    <SuperTokensWrapper>
      <div className="App">
        <Router>
          <div className="fill">
            <Routes>
              // highlight-start 
              {getSuperTokensRoutesForReactRouterDom(reactRouterDOM, [ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])}
              // highlight-end 
              // ... other routes
            </Routes>
          </div>
        </Router>
      </div>
    </SuperTokensWrapper>
  );
}
```

</Answer>

<Answer title="No">

```tsx
import { SuperTokensWrapper } from "supertokens-auth-react";
import { canHandleRoute, getRoutingComponent } from "supertokens-auth-react/ui";
import { ThirdPartyEmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/thirdpartyemailpassword/prebuiltui"; 
import { TOTPPreBuiltUI } from "supertokens-auth-react/recipe/totp/prebuiltui";

function App() {
  // highlight-start
  if (canHandleRoute([ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])) {
      return getRoutingComponent([ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])
  }
  // highlight-end
  return (
    <SuperTokensWrapper>{/*Your app*/}</SuperTokensWrapper>
  );
}
```

</Answer>

</Question>

</TabItem>

</FrontendPreBuiltUITabs>

With the above configuration, users will see emailpassword or social login UI when they visit the auth page. After completing that, users will be redirected to `/auth/mfa/totp` (assuming that the `websiteBasePath` is `/auth`) where they will be asked to setup the factor, or complete the TOTP challenge if they have already setup the factor before. The UI for this screen looks like:
- [Factor Setup UI](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/totp-mfa--device-setup-with-single-next-option)
- [Verification UI](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/totp-mfa--verification-with-single-next-option) (In case the factor is already setup before).

</PreBuiltUIContent>

<CustomUIContent>

We start by initialising the MFA and TOTP recipe on the frontend like so:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import SuperTokens from 'supertokens-web-js';
import MultiFactorAuth from 'supertokens-web-js/recipe/multifactorauth';
import Totp from "supertokens-web-js/recipe/totp";

SuperTokens.init({
    appInfo: {
        apiDomain: "...",
        apiBasePath: "...",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        // highlight-start
        MultiFactorAuth.init(),
        Totp.init()
        // highlight-end
    ],
});
```

</TabItem>

<TabItem value="script">

```tsx
import supertokens from "supertokens-web-js-script";
import supertokensMultiFactorAuth from 'supertokens-web-js-script/recipe/multifactorauth';
import supertokensTotp from "supertokens-web-js-script/recipe/totp";
supertokens.init({
    appInfo: {
        apiDomain: "...",
        apiBasePath: "...",
        appName: "...",
    },
    recipeList: [
        // other recipes...
        // highlight-start
        supertokensMultiFactorAuth.init(),
        supertokensTotp.init()
        // highlight-end
    ],
});
```

</TabItem>


</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

:::success
This step is not applicable for mobile apps. Please continue reading.
:::

</TabItem>

</FrontendCustomUITabs>

After the first factor login, you should start by [checking the access token payload and see if the MFA claim's `v` boolean is `false`](../frontend-setup#step-2-checking-the---custv-boolean-value-in-the-mfa-claim--cust). If it's not, then we can redeirect the user to the application page.

If it's `false`, the frontend then needs to [call the MFA endpoint](../frontend-setup#mfa-info-endpoint) to get information about which factor the user should be asked to complete next. Based on the backend config in this page, the `next` array will contain `["totp"]`.

There are two possibilities here:
- Case 1: The user needs to setup a TOTP device cause they don't have any.
- Case 2: The user already has a verified device setup and needs to complete the TOTP challenge.

We can know which case it is by checking if `"totp"` is one of the items in the `factorsThatAreAlreadySetup` array that is returned from the API call above. If it is in the array, then it's case 2, otherwise it's case 1.

#### Case 1 implementation: User needs to setup a new TOTP device
In this case, we do two things:
- Call an API on the backend to create a device. This returns the device secret that can be displayed to the user. The user is supposed to scan this using their authenticator app, to add a new entry for your app in their authenticator app.
- Then the user needs to enter the TOTP code that's displayed to them in the app, and this needs to be sent to the backend to mark the device as verified. Once a device is marked as verified, only then will the `factorsThatAreAlreadySetup` array contain `"totp"` the next time they login.

To create a new device, call the following API:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import Totp from "supertokens-web-js/recipe/totp"
import Session from "supertokens-web-js/recipe/session"

async function createNewTotpDevice() {
    if (await Session.doesSessionExist()) {
        try {
            let deviceResponse = await Totp.createDevice();
            if (deviceResponse.status === "DEVICE_ALREADY_EXISTS_ERROR") {
                // this should only come here if you are passing a custom device name when calling the above function.
                throw new Error("Should never come here")
                // device created successfully
            }
            // device created successfully
            let qrCodeString = deviceResponse.qrCodeString;
            let secret = deviceResponse.secret;

            // TODO: display a QR code based on qrCodeString, and also an option to view
            // the secret if the user is unable to scan the QR code.
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP device creation can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

<TabItem value="script">

```tsx
import supertokensTotp from "supertokens-web-js-script/recipe/totp"
import supertokensSession from "supertokens-web-js-script/recipe/session"
async function createNewTotpDevice() {
    if (await supertokensSession.doesSessionExist()) {
        try {
            let deviceResponse = await supertokensTotp.createDevice();
            if (deviceResponse.status === "DEVICE_ALREADY_EXISTS_ERROR") {
                // this should only come here if you are passing a custom device name when calling the above function.
                throw new Error("Should never come here")
                // device created successfully
            }
            // device created successfully
            let qrCodeString = deviceResponse.qrCodeString;
            let secret = deviceResponse.secret;

            // TODO: display a QR code based on qrCodeString, and also an option to view
            // the secret if the user is unable to scan the QR code.
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP device creation can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain>

Notice that the API call requires the session's access token as an input (this should be added by our frontend SDK automatically):

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/totp/device' \
--header 'rid: totp' \
--header 'Authorization: Bearer ...'
```

</AppInfoForm>

The above API call returns the following response:

```json
{
    "status": "OK",
    "issuerName": "...",
    "deviceName": "TOTP Device 1",
    "secret": "....",
    "userIdentifier": "user@example.com",
    "qrCodeString": "..."    
} | {
    "status": "DEVICE_ALREADY_EXISTS_ERROR" | "GENERAL_ERROR"
}
```

</TabItem>

</FrontendCustomUITabs>

- When device registeration is successful, the API returns:
    - The `secret` and `qrCodeString` which are to be displayed to the user. For React apps, we recommend using the [react-qr-code library](https://github.com/rosskhanas/react-qr-code) to display the QR code.
    - The `issuerName` is the name will show up on the TOTP app for the user. By default, this is equal to the `appName` config on the backend sdk, however, you can change it to something else in the backend `totp.init` config.
    - The `userIdentifier` is the email / phone number of the user based on the first factor. This will also be shown in the TOTP app along with the `issuerName`.
- The API call can also take a `deviceName` (as a POST body prop) which attemps to create a TOTP device with the provideed name. A status of `"DEVICE_ALREADY_EXISTS_ERROR"` is returned in case a verified device with the input name already exists. In this case, you should ask the user to enter a different name. Note that this status is only returned in case you are passing in a custom device name. The default naming strategy is to name the device "TOTP Device N", where we start N from 1, and keep increasing it. This value can be used to identify a device from the backend point of view, for operations like deleting a device.
- A status of `"GENERAL_ERROR"` is returned in case you specifically return that from a backend API override.

Once a device has been created, and scanned, you need to ask the user to enter the TOTP and call the API below to verify it:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import Totp from "supertokens-web-js/recipe/totp"
import Session from "supertokens-web-js/recipe/session"

async function verifyTotpDevice(deviceName: string, userInputTotp: string) {
    if (await Session.doesSessionExist()) {
        try {
            let verifyResponse = await Totp.verifyDevice({
                deviceName,
                totp: userInputTotp,
            });
            if (verifyResponse.status === "UNKNOWN_DEVICE_ERROR") {
                // this can happen due to a race condition wherein the device is deleted before verifying.
                window.alert("Something went wrong. Please reload and try again");
            } else if (verifyResponse.status === "LIMIT_REACHED_ERROR") {
                // this can happen if the user has entered a wrong TOTP too many times.
                window.alert("Totp incorrect. Please try again in " + (verifyResponse.retryAfterMs / 1000) + " seconds");
            } else if (verifyResponse.status === "INVALID_TOTP_ERROR") {
                window.alert("Totp incorrect. Please try again");
            } else {
                // Device verified successfully
            }
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP device verification can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

<TabItem value="script">

```tsx
import supertokensTotp from "supertokens-web-js-script/recipe/totp"
import supertokensSession from "supertokens-web-js-script/recipe/session"
async function verifyTotpDevice(deviceName: string, userInputTotp: string) {
    if (await supertokensSession.doesSessionExist()) {
        try {
            let verifyResponse = await supertokensTotp.verifyDevice({
                deviceName,
                totp: userInputTotp,
            });
            if (verifyResponse.status === "UNKNOWN_DEVICE_ERROR") {
                // this can happen due to a race condition wherein the device is deleted before verifying.
                window.alert("Something went wrong. Please reload and try again");
            } else if (verifyResponse.status === "LIMIT_REACHED_ERROR") {
                // this can happen if the user has entered a wrong TOTP too many times.
                window.alert("Totp incorrect. Please try again in " + (verifyResponse.retryAfterMs / 1000) + " seconds");
            } else if (verifyResponse.status === "INVALID_TOTP_ERROR") {
                window.alert("Totp incorrect. Please try again");
            } else {
                // Device verified successfully
            }
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP device verification can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain>

Notice that the API call requires the session's access token as an input (this should be added by our frontend SDK automatically):

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/totp/device/verify' \
--header 'rid: totp' \
--header 'Authorization: Bearer ...'
--header 'Content-Type: application/json' \
--data-raw '{
    "deviceName": "...",
    "totp": "..."
}'
```

</AppInfoForm>

The above API call returns the following response:

```json
{
        "status": "OK",
        "wasAlreadyVerified": false
} | {
        "status": "INVALID_TOTP_ERROR",
        "currentNumberOfFailedAttempts": 1,
        "maxNumberOfFailedAttempts": 5
} | {
        "status": "LIMIT_REACHED_ERROR",
        "retryAfterMs": 900000
} | {
        "status": "UNKNOWN_DEVICE_ERROR" | "GENERAL_ERROR"
}
```

</TabItem>

</FrontendCustomUITabs>

- The `deviceName`, which is an input to the API is one of the props returned from the previous API call to create a device.
- When verification is successful (`status: "OK"`), the device is marked as verified in the database and can be used for the TOTP challenge next time around. The boolean `wasAlreadyVerified` indicates if the device was already verified before this call was made.
- A status of `INVALID_TOTP_ERROR` means that the user has entered the an incorrect TOTP and needs to retry. The response contains two other props:
    - `currentNumberOfFailedAttempts`: The number of times the user has entered an incorrect TOTP so far.
    - `maxNumberOfFailedAttempts`: The maximum number of times the user can enter an incorrect TOTP before they are asked to wait (see `status: LIMIT_REACHED_ERROR`). This is set to 5 by default in the core. You can change this value by setting the `totp_max_attempts` in the core config.
- A status of `LIMIT_REACHED_ERROR` indicates that the user has entered an incorrect TOTP too many times and must wait before trying again (otherwise even valie TOTPs will fail). The waiting period is indicated by the `retryAfterMs` prop in the response body. By default, it is 15 mins, but it can be chanegd by setting the value for `totp_rate_limit_cooldown_sec` in the core config.
- A status of `UNKNOWN_DEVICE_ERROR` is possible due to a racce condition in which the device is somehow deleted before the verification call is made.
- A status of `GENERAL_ERROR` is possible if you specifically return that from a backend API override.

On successful verification of a device, the `totp` factor is marked as completed and the `v` value is updated in the session based on if there are any more factors that the user needs to complete. The next step would be to check this `v` value in the MFA claim and redirect the user to the application page, or get information about the next factor using the [MFA info endpoint](../frontend-setup#mfa-info-endpoint).

#### Case 2 implementation: User needs to complete the TOTP challenge

This case is when the user already has a device setup (`totp` is in `factorsThatAreAlreadySetup`), and needs to complete the TOTP challenge. In this case, you should show the user an input box asking them to enter their TOTP from the authenticator app and then call the following API:

<FrontendCustomUITabs>

<TabItem value="web">

<NpmOrScriptTabs>

<TabItem value="npm">

```tsx
import Totp from "supertokens-web-js/recipe/totp"
import Session from "supertokens-web-js/recipe/session"

async function verifyTotpCode(userInputTotp: string) {
    if (await Session.doesSessionExist()) {
        try {
            let verifyResponse = await Totp.verifyCode({
                totp: userInputTotp,
            });
            if (verifyResponse.status === "LIMIT_REACHED_ERROR") {
                // this can happen if the user has entered a wrong TOTP too many times.
                window.alert("Totp incorrect. Please try again in " + (verifyResponse.retryAfterMs / 1000) + " seconds");
            } else if (verifyResponse.status === "INVALID_TOTP_ERROR") {
                window.alert("Totp incorrect. Please try again");
            } else {
                // Code verified successfully
            }
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP code verification can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

<TabItem value="script">

```tsx
import supertokensTotp from "supertokens-web-js-script/recipe/totp"
import supertokensSession from "supertokens-web-js-script/recipe/session"
async function verifyTotpCode(userInputTotp: string) {
    if (await supertokensSession.doesSessionExist()) {
        try {
            let verifyResponse = await supertokensTotp.verifyCode({
                totp: userInputTotp,
            });
            if (verifyResponse.status === "LIMIT_REACHED_ERROR") {
                // this can happen if the user has entered a wrong TOTP too many times.
                window.alert("Totp incorrect. Please try again in " + (verifyResponse.retryAfterMs / 1000) + " seconds");
            } else if (verifyResponse.status === "INVALID_TOTP_ERROR") {
                window.alert("Totp incorrect. Please try again");
            } else {
                // Code verified successfully
            }
        } catch (err: any) {
            if (err.isSuperTokensGeneralError === true) {
                // this may be a custom error message sent from the API by you.
                window.alert(err.message);
            } else {
                window.alert("Oops! Something went wrong.");
            }
        }
    } else {
        throw new Error("TOTP code verification can only happen after the first factor is complete and when a session exists")
    }
}
```

</TabItem>

</NpmOrScriptTabs>

</TabItem>

<TabItem value="mobile">

<AppInfoForm askForAPIDomain>

Notice that the API call requires the session's access token as an input (this should be added by our frontend SDK automatically):

```bash
curl --location --request POST '^{form_apiDomain}^{form_apiBasePath}/totp/verify' \
--header 'rid: totp' \
--header 'Authorization: Bearer ...'
--header 'Content-Type: application/json' \
--data-raw '{
    "totp": "..."
}'
```

</AppInfoForm>

The above API call returns the following response:

```json
{
        "status": "OK" | "UNKNOWN_USER_ID_ERROR"
} | {
        "status": "INVALID_TOTP_ERROR",
        "currentNumberOfFailedAttempts": 1,
        "maxNumberOfFailedAttempts": 5,
} | {
        "status": "LIMIT_REACHED_ERROR",
        "retryAfterMs": 900000,
} | {
        "status": "GENERAL_ERROR"
}
```

</TabItem>

</FrontendCustomUITabs>

- A `status: OK` indicates that verification was successful. SuperTokens tries and verifies the input TOTP against all verified devices that belong to this user.
- A status of `INVALID_TOTP_ERROR` means that the user has entered the an incorrect TOTP and needs to retry. The response contains two other props:
    - `currentNumberOfFailedAttempts`: The number of times the user has entered an incorrect TOTP so far.
    - `maxNumberOfFailedAttempts`: The maximum number of times the user can enter an incorrect TOTP before they are asked to wait (see `status: LIMIT_REACHED_ERROR`). This is set to 5 by default in the core. You can change this value by setting the `totp_max_attempts` in the core config.
- A status of `LIMIT_REACHED_ERROR` indicates that the user has entered an incorrect TOTP too many times and must wait before trying again (otherwise even valie TOTPs will fail). The waiting period is indicated by the `retryAfterMs` prop in the response body. By default, it is 15 mins, but it can be chanegd by setting the value for `totp_rate_limit_cooldown_sec` in the core config.
- A status of `UNKNOWN_USER_ID_ERROR` is possible due to a racce condition in which all devices that the user had are deleted by the time this API is called. In this case, you can ask users to setup a new device.
- A status of `GENERAL_ERROR` is possible if you specifically return that from a backend API override.

On successful verification of the code, the `totp` factor is marked as completed and the `v` value is updated in the session based on if there are any more factors that the user needs to complete. The next step would be to check this `v` value in the MFA claim and redirect the user to the application page, or get information about the next factor using the [MFA info endpoint](../frontend-setup#mfa-info-endpoint).

</CustomUIContent>

</PreBuiltOrCustomUISwitcher>

## Multi tenant setup

In a multi tenancy setup, you may want to enable TOTP for all users, across all tenants, or for all users within specific tenants. For enabling for all users across all tenants, it's the same steps as in the [single tenant setup](#single-tenant-setup) section above, so in this section, we will focus on enabling TOTP for all users within specific tenants.

### Backend setup

To start, we will initialise the TOTP and the MultiFactorAuth recipes in the following way:

<BackendSDKTabs>
<TabItem value="nodejs">

```ts
import supertokens from "supertokens-node";
import ThirdPartyEmailPassword from "supertokens-node/recipe/thirdpartyemailpassword"
import MultiFactorAuth from "supertokens-node/recipe/multifactorauth"
import totp from "supertokens-node/recipe/totp"
import Session from "supertokens-node/recipe/session"

supertokens.init({
    supertokens: {
        connectionURI: "..."
    },
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "..."
    },
    recipeList: [
        Session.init(),
        ThirdPartyEmailPassword.init({
            //...
        }),
        // highlight-start
        totp.init(),
        MultiFactorAuth.init()
        // highlight-end
    ]
})
```

</TabItem>
<TabItem value="go">

:::note
Coming soon.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon.
:::

</TabItem>
</BackendSDKTabs>

Unlike the single tenant setup, we do not provide any config to the `MultiFactorAuth` recipe cause all the necessary configuration will be done on a tenant level.

To configure TOTP requirement for a tenant, we can call the following API:

<BackendSDKTabs enableCurl>

<TabItem value="nodejs">

```tsx
import Multitenancy from "supertokens-node/recipe/multitenancy";

async function createNewTenant() {
    let resp = await Multitenancy.createOrUpdateTenant("customer1", {
        emailPasswordEnabled: true,
        thirdPartyEnabled: true,
        firstFactors: ["emailpassword", "thirdparty"],
        requiredSecondaryFactors: ["totp"]
    });

    if (resp.createdNew) {
        // Tenant created successfully
    } else {
        // Existing tenant's config was modified.
    }
}
```

</TabItem>
<TabItem value="go">

:::note
Coming soon.
:::

</TabItem>
<TabItem value="python">

:::note
Coming soon.
:::

</TabItem>

<TabItem value="curl">

<CoreInjector defaultValue="http://localhost:3567" showAppId={false}>

```bash
curl --location --request PUT '^{coreInjector_uri_without_quotes}/appid-<APP_ID>/recipe/multitenancy/tenant' \
--header 'api-key: ^{coreInjector_api_key_without_quotes}' \
--header 'Content-Type: application/json' \
--data-raw '{
    "tenantId": "customer1",
    "emailPasswordEnabled": true,
    "thirdPartyEnabled": true,
    "firstFactors": ["emailpassword", "thirdparty"],
    "requiredSecondaryFactors": ["totp"]
}'
```

</CoreInjector>

</TabItem>

</BackendSDKTabs>

- In the above, we set the `firstFactors` to `["emailpassword", "thirdparty"]` to indicate that the first factor can be either emailpassword or thirdparty. We also configure that `emailPasswordEnabled` and `thirdPartyEnabled` are enabled for the tenant.
- We set the `requiredSecondaryFactors` to `["totp"]` to indicate that TOTP is required for all users in this tenant. The default implementation of `getMFARequirementsForAuth` in the `MultiFactorAuth` takes this into account.

Once the user finishes the first factor (for example, with emailpassword), their session access token payload will look like this:
```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
        },
        "v": false
    }
}
```

The `v` being `false` indicates that there are still factors that are pending. After the user has finished totp, the payload will look like:

```json
{
    "st-mfa": {
        "c": {
            "emailpassword": 1702877939,
            "totp": 1702877999
        },
        "v": true
    }
}
```

Indicating that the user has finished all required factors, and should be allowed to access the app.


### Frontend setup

<PreBuiltOrCustomUISwitcher>

<PreBuiltUIContent>

We start by modifying the `init` function call on the frontend like so:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

```tsx
import supertokens from "supertokens-auth-react"
import ThirdPartyEmailPassword from "supertokens-auth-react/recipe/thirdpartyemailpassword"
import MultiFactorAuth from "supertokens-auth-react/recipe/multifactorauth"
import totp from "supertokens-auth-react/recipe/totp"
import Multitenancy from "supertokens-auth-react/recipe/multitenancy"

supertokens.init({
    appInfo: {
        appName: "...",
        apiDomain: "...",
        websiteDomain: "...",
    },
    // highlight-next-line
    usesDynamicLoginMethods: true,
    recipeList: [
        ThirdPartyEmailPassword.init( /* ... */),
        // highlight-start
        totp.init(),
        MultiFactorAuth.init(),
        Multitenancy.init({
            override: {
                functions: (originalImplementation) => {
                    return {
                        ...originalImplementation,
                        getTenantId: async (context) => {
                            return "TODO"
                        }
                    }
                }
            }
        })
        // highlight-end
    ]
})
```

</TabItem>

</FrontendPreBuiltUITabs>

- Just like on the backend, we init the `totp` recipe in the `recipeList`.
- We also init the `MultiFactorAuth` recipe. Notice that unlike the single tenant setup, we do not specify the `firstFactors` here. That information is fetched based on the tenantId you provide the SDK with.
- We have set `usesDynamicLoginMethods: true` so that the SDK knows to fetch the login methods dynamically based on the tenantId.
- Finally, we init the multi tenancy recipe and provide a method for getting the tenantId. 

Next, we need to add the TOTP pre built UI when rendering the SuperTokens component:

<FrontendPreBuiltUITabs>

<TabItem value="reactjs">

<Question
    question="Do you use react-router-dom?">
<Answer title="Yes">

```tsx
import { SuperTokensWrapper } from "supertokens-auth-react";
import { getSuperTokensRoutesForReactRouterDom } from "supertokens-auth-react/ui";
import { ThirdPartyEmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/thirdpartyemailpassword/prebuiltui"; 
import { TOTPPreBuiltUI } from "supertokens-auth-react/recipe/totp/prebuiltui";
import reactRouterDOM, { Routes, BrowserRouter as Router, Route } from "react-router-dom";

function App() {
  return (
    <SuperTokensWrapper>
      <div className="App">
        <Router>
          <div className="fill">
            <Routes>
              // highlight-start 
              {getSuperTokensRoutesForReactRouterDom(reactRouterDOM, [ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])}
              // highlight-end 
              // ... other routes
            </Routes>
          </div>
        </Router>
      </div>
    </SuperTokensWrapper>
  );
}
```

</Answer>

<Answer title="No">

```tsx
import { SuperTokensWrapper } from "supertokens-auth-react";
import { canHandleRoute, getRoutingComponent } from "supertokens-auth-react/ui";
import { ThirdPartyEmailPasswordPreBuiltUI } from "supertokens-auth-react/recipe/thirdpartyemailpassword/prebuiltui"; 
import { TOTPPreBuiltUI } from "supertokens-auth-react/recipe/totp/prebuiltui";

function App() {
  // highlight-start
  if (canHandleRoute([ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])) {
      return getRoutingComponent([ThirdPartyEmailPasswordPreBuiltUI, TOTPPreBuiltUI])
  }
  // highlight-end
  return (
    <SuperTokensWrapper>{/*Your app*/}</SuperTokensWrapper>
  );
}
```

</Answer>

</Question>

</TabItem>

</FrontendPreBuiltUITabs>

With the above configuration, users will see the first and second factor based on the tenant configuration. For the tenant we configured above, users will see email password or social login first. After completing that, users will be redirected to `/auth/mfa/totp` (assuming that the `websiteBasePath` is `/auth`) where they will be asked to setup the factor, or complete the TOTP challenge if they have already setup the factor before. The UI for this screen looks like:
- [Factor Setup UI](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/totp-mfa--device-setup-with-single-next-option)
- [Verification UI](https://6571be2867f75556541fde98-xieqfaxuuo.chromatic.com/?path=/story/totp-mfa--verification-with-single-next-option) (In case the factor is already setup before).

</PreBuiltUIContent>

<CustomUIContent>

The steps here are the same as in [the single tenant setup above](#frontend-setup).

</CustomUIContent>

</PreBuiltOrCustomUISwitcher>

<!-- COPY SECTION -->
<!-- ./mfa/totp/totp-for-all-users.mdx -->
<!-- 1 -->

## Protecting frontend and backend routes

See the section on [protecting frontend and backend routes](../protect-routes).

## Frontend events, pre and post API hooks

TODO..

<!-- END COPY SECTION -->
